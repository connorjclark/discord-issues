## ❌Layered Lock Blocks Don't Work by Default (#2957)
@connorjclark (discord: connorclark) opened this issue on 01/05/2024
Status: unknown
Tags: 
Source: #dev-discussion https://discord.com/channels/876899628556091432/1192736536484139028


=== @connorjclark (discord: connorclark) 01/05/2024 07:49

Nearly at a point where I can merge more of the ZASM optimization. @EmilyV99 (discord: Emily) in case you want to take a look at some of the before/afters, here's the details.

Code is here: https://github.com/connorjclark/ZeldaClassic/blob/zasm-compare-opt/src/zc/zasm_optimize.cpp

See how much is saved in some quests: https://github.com/connorjclark/ZeldaClassic/tree/zasm-compare-opt/tests/snapshots/optimize_zasm . This is broken down per-pass:

```
Finished optimizing scripts:
    [goto_next_instruction] saved 11813 instr (0.1%)
    [unreachable_blocks] saved 55701 instr (0.4%)
    [optimize_conseq_additive] saved 149217 instr (1.1%)
    [setv_pushr] saved 373538 instr (2.8%)
    [spurious_branches] saved 0 instr (0.0%)
    [reduce_comparisons] saved 266663 instr (2.0%)
    [unreachable_blocks_2] saved 51412 instr (0.4%)
    [total] saved 908344 instr (6.7%)
```

`spurious_branches` always reports saving 0 instructions,  but that's because it only rewrites GOTOs to skip pointless branches. The final `unreachable_blocks_2` runs to actually delete those 100% unused branches.

There's a bunch of syntentic ZASM snippets that serve as test cases. This is all of them, followed by their current output post-optimization: https://gist.github.com/connorjclark/7c924bc58f980e78d5919a8cbcc4a244

=== @EmilyV99 (discord: Emily) 01/05/2024 07:51

I've been peeking a bit as you've been committing, and it's looked pretty good from that at least

=== @EmilyV99 (discord: Emily) 01/05/2024 07:52

...what is the purpose/difference here by using `.operator==()` instead of ` == `?
![image](https://cdn.discordapp.com/attachments/1192736536484139028/1192737419234119690/image.png?ex=65eac3c8&is=65d84ec8&hm=de3ebd51cdd176a0f223f7f6f13ee7410e891e76871b2fa4a2190ff377449c70&)

=== @connorjclark (discord: connorclark) 01/05/2024 07:52

`optimize_conseq_additive`: this is all the POP -> POPARGS stuff

`spurious_branches`: for every branch, it infers what must be true if the branch is taken, simulates taking that branch, and if it determines there are no side effects and further branches are taken, will skip all that indirection and jump directly to the final block.

`reduce_comparisons`: turns a sequence of CASTBOOL/COMPARE/SETX instructions into a minimal equivalent
Somehow, that broke under MSVC when done as your mentioned. That's how I had it at first.

=== @EmilyV99 (discord: Emily) 01/05/2024 07:53

huh, odd.

=== @connorjclark (discord: connorclark) 01/05/2024 07:53

It's some C++17 breaking change that only MSVC adheres to.
I did not understand it.
Something about recursive equality operators being illegal now, idk

=== @EmilyV99 (discord: Emily) 01/05/2024 07:54

...ohh, because that is calling *itself*
interesting

=== @connorjclark (discord: connorclark) 01/05/2024 07:54

yeah but, on another instance. so I don't get why the fuss
if it were itself I might kinda get it.

=== @EmilyV99 (discord: Emily) 01/05/2024 07:55

yeah, doesn't seem fully sensible

=== @connorjclark (discord: connorclark) 01/05/2024 07:56

This is yuurand on my machine:

```
Finished optimizing scripts:
        [goto_next_instruction] saved 11813 instr (0.1%), took 36 ms
        [unreachable_blocks] saved 55701 instr (0.4%), took 497 ms
        [optimize_conseq_additive] saved 149217 instr (1.1%), took 82 ms
        [setv_pushr] saved 373538 instr (2.8%), took 15 ms
        [spurious_branches] saved 0 instr (0.0%), took 126 ms
        [reduce_comparisons] saved 266663 instr (2.0%), took 371 ms
        [unreachable_blocks_2] saved 51412 instr (0.4%), took 524 ms
        [total] saved 908344 instr (6.7%), took 2193 ms
```

2s, which isn't bad when you realize this is for _all_ the scripts at once, on a single core.
I just need to tweak it to only optimize just before it runs a script for the first time, not all up front, then this should be totally fine.

=== @EmilyV99 (discord: Emily) 01/05/2024 07:57

*2 seconds for all that*?
wow, that's fast

=== @connorjclark (discord: connorclark) 01/05/2024 10:01

since D5 is the null register, can I opt this further?

```
Function #592
206181: RECT                                         [Block 0 -> ]
206182: NOP                                          
206183: NOP                                          
206184: NOP                                          
206185: NOP                                          
206186: NOP                                          
206187: NOP                                          
206188: NOP                                          
206189: NOP                                          
206190: NOP                                          
206191: NOP                                          
206192: NOP                                          
206193: POPARGS         D3              12           
206194: POP             D5                           
206195: POP             D3                           
206196: GOTOR           D3                          
```
`POPAGS D3 14`

=== @EmilyV99 (discord: Emily) 01/05/2024 10:08

aye
that should be valid

=== @EmilyV99 (discord: Emily) 01/05/2024 10:15

by definition nothing should ever read from d5, basically

=== @connorjclark (discord: connorclark) 01/06/2024 05:39

wait can D5 be a valid read from initd
```
Function #0
    0: PUSHR           D0                           [Block 0 -> 1, 2]
    1: PUSHR           D1                           
    2: PUSHR           D2                           
    3: PUSHR           D3                           
    4: PUSHR           D4                           
    5: PUSHR           D5                           
    6: PUSHR           D6                           
```
-> 

```
Function #0
    0: PUSHR           D0                           [Block 0 -> 1, 2]
    1: PUSHR           D1                           
    2: PUSHR           D2                           
    3: PUSHR           D3                           
    4: PUSHR           D4                           
    5: PUSHARGSR       D6              2            
    6: NOP                                          
```

breaks a replay

=== @EmilyV99 (discord: Emily) 01/06/2024 05:43

oh ffs
yes
ONLY there
because, that's not using it as a NUL register
that's literally just filling the 8 registers with the 8 initd
....we really should change it so the initd just gets pushed directly to the stack, instead of put into registers that are pushed at the start of the script....
would save ALL of those push opcodes at the start
for the record, D5 should not *appear* in any other `PUSHR` command except for exactly there?
It otherwise should only ever appear in `POP`s

=== @connorjclark (discord: connorclark) 01/06/2024 06:55

loadi -> loadd 2x-3x the trimmed ops 👀

=== @connorjclark (discord: connorclark) 01/06/2024 06:57

can I assume LOADI only ever appears exactly as this (just varying on the write register for LOADI):

```
177: SETR            D6              D4           
178: ADDV            D6              40000        
179: LOADI           D2              D6           
```

=== @connorjclark (discord: connorclark) 01/06/2024 06:59

```cpp
// SETR, ADDV, LOADI -> LOADD
// Ex:
//   SETR            D6              D4
//   ADDV            D6              40000
//   LOADI           X               D6
// ->
//   LOADD           X               40000
```

=== @EmilyV99 (discord: Emily) 01/06/2024 07:00

aye, as far as I'm aware
LOADD was my addition specifically... well, for the exact same reason you're doing it here lol

=== @connorjclark (discord: connorclark) 01/06/2024 07:34


![image](https://cdn.discordapp.com/attachments/1192736536484139028/1193095314668802209/image.png?ex=65ec1119&is=65d99c19&hm=406ce14d6192079dd150abf86aac9ef60ad3b6ee073efd752398e877ef2e570f&)
why does this keep pushing/popping D0
i know D0 and D1 are used to access SCRIPTRAM
but whats up with stack dance between all those `SETV D2`

=== @connorjclark (discord: connorclark) 01/06/2024 07:42

ok, so it cant assume in the visitor for this thing that the node that produces D1 or D2 doesnt stomp on D0 so it does this, that makes sense.

=== @connorjclark (discord: connorclark) 01/06/2024 07:49

if only passing rINDEX and rINDEX2 like this were instead just pushing onto the stack, then SCRIPTRAM would pop from the stack... woulda been hella simpler

=== @EmilyV99 (discord: Emily) 01/06/2024 07:53

(replying to @connorjclark (discord: connorclark) "ok, so it cant assume in the…"): yeah, because that `SETV D2` is a constant being read, but it could be any expression, including another read from an array using D0

=== @EmilyV99 (discord: Emily) 01/06/2024 08:15

> // TODO: zasm_optimize should change old calls to CALLFUNC.
ooh, that'd be smart

=== @connorjclark (discord: connorclark) 01/06/2024 08:18

Before I can do that, I think I need to know how many arguments a function takes

And then count backwards on the stack and delete the thing the pushes the return address

And the one that pushes in the function
Could also not, but defeats most of the purpose

=== @EmilyV99 (discord: Emily) 01/06/2024 08:23


![image](https://cdn.discordapp.com/attachments/1192736536484139028/1193107546379132928/image.png?ex=65ec1c7d&is=65d9a77d&hm=e89ebd7e93bfd5c8470b182d868e8bef79ab5c89082190c9ab172272cb117e94&)
In older code (pre `CALLFUNC`), it should always come immediately after the SFRAME is pushed
...though, there is the possible problem of one of the parameters *including another function call*
but, presumably you can know where function calls are occurring in some way to handle that

=== @EmilyV99 (discord: Emily) 01/06/2024 08:25

(well, actually, even simpler, it always POPS the SFRAME after a function....
(so you could like, just walk backwards from the function call's GOTO, if you hit a `POP d4`, ignore the next `PUSHR d4` that you find, otherwise when you hit `PUSHR d4`, that must be the opcode before the return label is pushed

=== @EmilyV99 (discord: Emily) 01/06/2024 08:30

also, if you simulate the stack depth just counting push/pops, you can easily build the number of params, as the stack difference between the func call and the `PUSHR d4` that is it's stack frame push will be the return address plus the param count

=== @connorjclark (discord: connorclark) 01/06/2024 08:59

`POP D4`! good catch.

=== @connorjclark (discord: connorclark) 01/06/2024 09:04

is the same true for calling a constructor/deconstructor?

=== @connorjclark (discord: connorclark) 01/06/2024 09:30

I applied the much simpler check for `POP D4` and instantly found I had overlooked recursive function calls.
It was marking those as the end of the block in the CFG generation, which made the following commands "unreachable", so they got axed..

=== @EmilyV99 (discord: Emily) 01/06/2024 15:09

ah, damn! nice!

=== @EmilyV99 (discord: Emily) 01/06/2024 15:11

(replying to @connorjclark (discord: connorclark) "is the same true for calling…"): should definitely be- all function calls require it to ensure the sp is proper or w/e
oh, though uh
do note that class constructors technically have ***two distinct start labels***
one of which is used when calling it via `new`, normally
the other is used for constructor-inheritance, when you call one constructor of a class from another of the same class
(skips some general init stuff that should only happen once)

=== @EmilyV99 (discord: Emily) 01/06/2024 15:44

oh... and destructors, uh
destructors always start with the `STARTDESTRUCTOR` opcode, at least
and should *always* be considered reachable
....because uh, they are never jumped to. But they ARE used. Because they do weird shenanigans.

=== @connorjclark (discord: connorclark) 01/06/2024 19:13

What fixes does this need to work?

```c
class Car
{
    int speed;

    Car()
    {
        speed = 100;
        printf("Car vrooms at %d\n", speed);
    }

    Car(int speed)
    {
        this->speed = speed;
        printf("Car vrooms at %d\n", speed);
    }

    ~Car()
    {
        Trace("Bye Car\n");
    }
}

ffc script Classes
{
    void run()
    {
        while (true)
        {
            Car mycar;
            Car mycar2 = new Car(2000);
            Waitframe();
        }
    }
}
```
It always traces 0, and the deconstructor is never called.
(I have the optimizations off)

=== @EmilyV99 (discord: Emily) 01/06/2024 19:20

Well, you're passing a string literal to `Trace()`, which is incorrect (that would be `TraceS()`
that'll be printing the array pointer

=== @EmilyV99 (discord: Emily) 01/06/2024 19:22


![image](https://cdn.discordapp.com/attachments/1192736536484139028/1193273399422746764/image.png?ex=65ecb6f4&is=65da41f4&hm=054fbd80e2928b1603d4c85a4570d683f7e500ac1734e404671b99c98f9a9472&)
and the destructors certainly call for me
...I'm confused as to why it's printing 0 for the speed, though....
...oh, also, if you thought `Car mycar;` was default-constructing, you'd be wrong
that's just declaring an object that is nullptr
you *must* use `new` to construct an object
...the no-param constructor works fine
hmmmm

=== @connorjclark (discord: connorclark) 01/06/2024 19:26

(replying to @EmilyV99 (discord: Emily) "Well, you're passing a string…"): Hmmm can this become an error
At compile time

=== @EmilyV99 (discord: Emily) 01/06/2024 19:26

no, because tracing the array pointer is a valid thing
just not what you were trying to do
(for a string literal it doesn't make much sense, but, it doesn't know what the param is... just that it's any expression, that can cast to the `untyped` type, so almost anything)

=== @connorjclark (discord: connorclark) 01/06/2024 19:30

(replying to @EmilyV99 (discord: Emily) "...I'm confused as to why it'…"): this is the only problem that remains for me
the constructor with one param is not setting speed

=== @EmilyV99 (discord: Emily) 01/06/2024 19:30

yeah, something is fucky
...and uhh
I just changed the trace in the destructor
to just `Trace(-1)`
...and I now get this:
![image](https://cdn.discordapp.com/attachments/1192736536484139028/1193275471769649242/image.png?ex=65ecb8e2&is=65da43e2&hm=6bb2b0758e22fa62054490c4cbc71af6dc8c46f9944e661736d046bf9bcbbafa&)

=== @connorjclark (discord: connorclark) 01/06/2024 19:31

I'd set `[zeldadx] optimize_zasm = 0` first.
I did not test deconstructors, which is what I'm doing now.

=== @EmilyV99 (discord: Emily) 01/06/2024 19:31

or, oh, true, I did pull
...same result
possibly related #2553

=== @EmilyV99 (discord: Emily) 01/06/2024 19:33

```
 STARTDESTRUCTOR "Car"; Func[void ~Car()] Body Start
 SETR d4,SP
 TRACEV -1; InlineFunc[void Trace(untyped)] Params AND InlineFunc[void Trace(untyped)] Body
 RETURNFUNC; Func[void ~Car()] Body End```
this is all that should run for the destructor though....

=== @connorjclark (discord: connorclark) 01/06/2024 19:34

could it be the \n

=== @EmilyV99 (discord: Emily) 01/06/2024 19:34

?
what \n

=== @connorjclark (discord: connorclark) 01/06/2024 19:35

nevermind, that just breaks zasm_to_string
not what the parser uses in editor

![image](https://cdn.discordapp.com/attachments/1192736536484139028/1193276706249789450/image.png?ex=65ecba08&is=65da4508&hm=283813ad036693c6a4148de0a54a902649ae4957b3341bd498e519a7299f1080&)

=== @EmilyV99 (discord: Emily) 01/06/2024 19:36

...oh uh
the constructor param thing
fixes if you change the name of the param...
pretty sure that's a fault in my "unused variable" logic....
bleh, should probably just disable that for class functions, the `this->` shit makes it too confusing

=== @connorjclark (discord: connorclark) 01/06/2024 19:37

here's the zasm for the 1 param ctor
```
Function #2
   37: SETV            D2              65           [Block 0 -> ]
   38: SETR            CLASS_THISKEY2  CLASS_THISKEY
   39: ZCLASS_CONSTRUCT CLASS_THISKEY   { 1 }       
   40: PUSHV           0                            
   41: SETR            D4              SP           
   42: PUSHR           CLASS_THISKEY2               
   43: ZCLASS_READ     CLASS_THISKEY   0            
   44: PUSHR           D2                           
   45: SETR            D2              CLASS_THISKEY
   46: SETR            D3              D2           
   47: POP             D2                           
   48: ZCLASS_WRITE    D3              0            
   49: ALLOCATEMEMV    D2              180000       
   50: STORED          D2              0            
   51: WRITEPODSTRING  D2              Car vrooms at %d

   52: LOADD           D2              0            
   53: PUSHR           D2                           
   54: ZCLASS_READ     CLASS_THISKEY   0            
   55: PUSHVARGR       D2                           
   56: PRINTFVARG                                   
   57: POP             D5                           
   58: LOADD           D3              0            
   59: DEALLOCATEMEMR  D3                           
   60: POPARGS         D5              2            
   61: SETR            D2              CLASS_THISKEY
   62: POP             CLASS_THISKEY                
   63: RETURNFUNC                                   
```

=== @EmilyV99 (discord: Emily) 01/06/2024 19:40

err?
where am I looking?
and for which of the two bugs?

=== @connorjclark (discord: connorclark) 01/06/2024 19:40

I'm just giving you a view into `Car(int speed)`
since it is printing 0 always

=== @EmilyV99 (discord: Emily) 01/06/2024 19:41

hmm, it's not my unused var optimization
you noted `d2 is being overwritten`
I'm clearly not on the same page as you

=== @connorjclark (discord: connorclark) 01/06/2024 19:41

yeah i erased that sorry

=== @EmilyV99 (discord: Emily) 01/06/2024 19:42

oh
lol

=== @connorjclark (discord: connorclark) 01/06/2024 19:42

I was thinking d2 was where the param lived...but this is not an entry function

=== @EmilyV99 (discord: Emily) 01/06/2024 19:42

params should all be on the stack

=== @connorjclark (discord: connorclark) 01/06/2024 19:42

here is the dtor

```
64: STARTDESTRUCTORCar                           
65: PUSHV           0                            
66: SETR            D4              SP           
67: ALLOCATEMEMV    D2              90000        
68: STORED          D2              0            
69: WRITEPODSTRING  D2              Bye Car
   
70: LOADD           D2              0            
71: PUSHR           D2                           
72: PRINTFVARG                                   
73: POP             D5                           
74: LOADD           D3              0            
75: DEALLOCATEMEMR  D3                           
76: POP             D5                           
77: RETURNFUNC                                   
```

=== @EmilyV99 (discord: Emily) 01/06/2024 19:42

`64: STARTDESTRUCTORCar`? (just an odd printout?)

=== @connorjclark (discord: connorclark) 01/06/2024 19:43

yes its just long
column needs to be a bit wider

=== @EmilyV99 (discord: Emily) 01/06/2024 19:43

oh uhh
`printf("Bye Car")` is the line you have there?

=== @connorjclark (discord: connorclark) 01/06/2024 19:44

it has a newline at the end
this is also just a visual issue with the zasm printer.
it does not serialize to string repr

=== @EmilyV99 (discord: Emily) 01/06/2024 19:45


![image](https://cdn.discordapp.com/attachments/1192736536484139028/1193279247368851496/image.png?ex=65ecbc66&is=65da4766&hm=7ecdcc1b4ed54464345f5db5aeff79971d6e2f486aac3a8400acec8748d5df71&)
....this....looks wrong to me... but it's also what I'm getting, and is working for me... wtf
oh wait no
duh
the format string is not a varg it's a normal param
nvm
only extra params would need PUSHVARGR
so, yeah, that destructor looks correct to me

=== @connorjclark (discord: connorclark) 01/06/2024 19:47

so its not being called?

=== @EmilyV99 (discord: Emily) 01/06/2024 19:47

it is being called for me 🤷‍♀️
```cpp
 STARTDESTRUCTOR "Car"; Func[void ~Car()] Body Start
 PUSHV 0
 SETR d4,SP
 ALLOCATEMEMV d2,9
 STORED d2,0
 WRITEPODSTRING d2,"Bye Car\n"
 LOADD d2,0; InlineFunc[void printf(char32)] Params Start
 PUSHR d2; InlineFunc[void printf(char32)] Params End
 PRINTFVARG; InlineFunc[void printf(char32)] Body Start
 POP d5; InlineFunc[void printf(char32)] Body End
 LOADD d3,0
 DEALLOCATEMEMR d3
 POP d5
 RETURNFUNC; Func[void ~Car()] Body End```
looks the same as yours...

=== @EmilyV99 (discord: Emily) 01/06/2024 19:49

As for the constructor, my guess is something is fucked with shadowing members
so `this->speed = speed` is reading the same as `this->speed = this->speed`
which, is 0-default, thus the 0 prints
happens without your opts, so, seems like my bug

=== @EmilyV99 (discord: Emily) 01/06/2024 19:50

also btw pretty sure all the stuff around the `CLASS_THISKEY` registers is a fucking mess that should be redone
on my list

=== @EmilyV99 (discord: Emily) 01/06/2024 19:52

(replying to @EmilyV99 (discord: Emily) "happens without your opts, so…"): oh for FUCKS SAKE

![image](https://cdn.discordapp.com/attachments/1192736536484139028/1193280886389620776/image.png?ex=65ecbded&is=65da48ed&hm=66878802e8ec4f338d8d5f5d1fd7cd51c0b263a7d208f8f67838f74e1f61da61&)
it's literally just backwards ffs

=== @connorjclark (discord: connorclark) 01/06/2024 19:53

do I need to free a class for the dtor. i assumed leaving scope would do it but that seems wrong now

=== @EmilyV99 (discord: Emily) 01/06/2024 19:54

the freeing code all happens automatically after the dtor ends
(if the user does not specify a dtor, there is no ZASM dtor, and the freeing stuff is all internal)
(replying to @EmilyV99 (discord: Emily) "...and I now get this:"): but something is definitely fucky
(replying to @EmilyV99 (discord: Emily) ""): fixed the param-constructor issue.
here's my code now:```cpp
class Car
{
    int speed;

    Car()
    {
        speed = 100;
        Trace(speed);
    }

    Car(int speed)
    {
        this->speed = speed;
        Trace(speed);
    }

    ~Car()
    {
        printf("Bye Car\n");
    }
}

ffc script Classes
{
    void run()
    {
        Car mycar = new Car();
        Car mycar2 = new Car(2000);
    }
}```
produces:
![image](https://cdn.discordapp.com/attachments/1192736536484139028/1193282051802157176/image.png?ex=65ecbf03&is=65da4a03&hm=898959c6d889947ae134b7f9f6357fc60f4d86398054a5f45e6a63d1cea0c542&)
(changing the constructor param name from `speed` to `spd` or literally anything that doesn't match the member will fix that for you, without needing me to push the fix and have you pull it)

=== @EmilyV99 (discord: Emily) 01/06/2024 19:59

...now to debug the thing I found earlier with dtors...
![image](https://cdn.discordapp.com/attachments/1192736536484139028/1193282772303880365/image.png?ex=65ecbfaf&is=65da4aaf&hm=de99e89147930438ed86ea64bb45bdd159b7ee1eac0a29517dfd925829d80106&)

=== @EmilyV99 (discord: Emily) 01/06/2024 20:00

gonna, uh, move this to #2553 as it's likely somehow related.

=== @EmilyV99 (discord: Emily) 01/06/2024 20:03

also for the record, you can `Ctrl+Click` the `Script Info` buttons in the slot-assign dialog to copy the parser ZASM output directly to your system clipboard
which can either include comments or not based on the checkbox for including comments at the bottom of that dialog

=== @EmilyV99 (discord: Emily) 01/06/2024 20:13

ahk @connorjclark (discord: connorclark) pushed 2 related fixes.

=== @connorjclark (discord: connorclark) 01/06/2024 20:44

thanks for the quick fixes!

=== @connorjclark (discord: connorclark) 01/06/2024 20:52

still need to figure out why the dtor is not called for me. the other traces work now.

```c
class Car
{
    int speed;

    Car()
    {
        speed = 100;
        Trace(speed);
    }

    Car(int speed)
    {
        this->speed = speed;
        Trace(speed);
    }

    ~Car()
    {
        Trace(-1);
    }
}

ffc script Classes
{
    void run()
    {
        while (true)
        {
            Car mycar = new Car();
            Car mycar2 = new Car(2000);
            Waitframe();
        }
    }
}
```
`scr_func_exec::execute` is never called

=== @EmilyV99 (discord: Emily) 01/06/2024 20:54

odd
What is the exact string in the `STARTDESTRUCTOR`? Does it have a newline or something?
(It shouldn't, it should match the class name exactly...)

=== @connorjclark (discord: connorclark) 01/06/2024 20:56

> STARTDESTRUCTOR "Car"; Func[void ~Car()] Body Start
what actualy calls a dtor? is it just do_freeclass?
b/c my zasm has no ZCLASS_FREE

=== @EmilyV99 (discord: Emily) 01/06/2024 20:57

should be
not only called by ZCLASS_FREE though
ZCLASS_FREE is an explicit `delete`
or, not then
nothing else calls do_freeclass, so it's something else, one sec
oh, err
it calls `obj->clear()`
which

=== @connorjclark (discord: connorclark) 01/06/2024 20:58

ArrayOwner::clear is the other place that calls it i guess

=== @EmilyV99 (discord: Emily) 01/06/2024 20:58

yeah, that
do you still have a while(true) in yours?
because like, if so, you would need to change screens to see the dtor
they don't auto-deconstruct based on scope or anything (only local arrays do that)
only at script exit

=== @connorjclark (discord: connorclark) 01/06/2024 20:59

ok thats it
thanks

=== @EmilyV99 (discord: Emily) 01/06/2024 21:00

yeah, with a loop there you're just constantly allocating more and will eventually run out of free pointers to allocate

=== @connorjclark (discord: connorclark) 01/06/2024 21:00

wanna make new/delete keywords in the vs ext?
![image](https://cdn.discordapp.com/attachments/1192736536484139028/1193298192465399940/image.png?ex=65ecce0b&is=65da590b&hm=a7f056fc39c45e9d06c2c95ab1ec63ea564ae6aee457ce18cfee51ebca8ea90f&)

=== @EmilyV99 (discord: Emily) 01/06/2024 21:02

oh, those aren't in there lol
they absolutely should be

=== @connorjclark (discord: connorclark) 01/06/2024 21:02

Finally got the test I wanted:

```c
class Car
{
    int speed;

    Car()
    {
        speed = 100;
        Trace(speed);
    }

    Car(int speed)
    {
        this->speed = speed;
        Trace(speed);
    }

    ~Car()
    {
        Trace(-1);
    }
}

ffc script Classes
{
    void run()
    {
        Car mycar = new Car();
        delete mycar;
        Waitframe();

        Car mycar2 = new Car(2000);
        Car mycar3 = new Car(5000);
        // Script exits, so last two instances dtors will be called.
    }
}
```

```
C 66 trace: 100.0000
C 66 trace: -1.0000
C 67 trace: 2000.0000
C 67 trace: 5000.0000
C 67 trace: -1.0000
C 67 trace: -1.0000
```

=== @EmilyV99 (discord: Emily) 01/06/2024 21:02

I'm about to be off for a while, shift just ended for tutoring and it's time to take apart my entire desk/PC setup to rearrange a ton of furniture and set up my new PC chair

=== @connorjclark (discord: connorclark) 01/06/2024 21:03

all good, I'm unblocked now. thanks again

=== @EmilyV99 (discord: Emily) 01/06/2024 21:03

glad I could help
and solved nasty bugs that have been lingering for a while anyway

=== @connorjclark (discord: connorclark) 01/06/2024 21:03

the power of a person clueless to how things work making a test

=== @EmilyV99 (discord: Emily) 01/06/2024 21:04

lol, yeah
I just debugged your destr by changing it to a normal trace and replicated a stack issue

=== @connorjclark (discord: connorclark) 01/06/2024 21:07

optimizations happen to not destroy the dtor due to unreachability

b/c its hanging onto the end of the last ctor
![image](https://cdn.discordapp.com/attachments/1192736536484139028/1193299858296164352/image.png?ex=65eccf98&is=65da5a98&hm=9177e3eefc4f474e046c9338ecff3dde485151d45a56b06ab19de321435aed22&)
and as a side effect of the function being ill constructed, the CFG just thinks of it as all one block

=== @EmilyV99 (discord: Emily) 01/06/2024 22:02

huh, odd lol
is it the lack of detecting a jump to it that's doing it?
(for the record, the `SETV d2,54` at the top of the constructor is the jump label)
the other interesting thing of note about destructors is, class objects can be saved to the save file....

=== @EmilyV99 (discord: Emily) 01/06/2024 22:05

and if the save file is re-loaded after ZASM has changed, it can no longer rely on that jump label being correct, thus why STARTDESTRUCTOR exists, so it can re-find it (...by... scanning through every opcode looking for it. You might be able to make that better if you like, keep a table of all STARTDESTRUCTOR points per script...)
(it only scans for it if it isn't where it expects it to be already, though, obviously)

=== @connorjclark (discord: connorclark) 01/06/2024 22:52

(replying to @EmilyV99 (discord: Emily) "is it the lack of detecting a…"): exactly - RETURNFUNC is not something the cfg creation checks when considering "what marks the end of a block". It jumps outside the execution of the function, and the CFG is meant just to model the interior. only interior jumps break up the instructions to blocks
normally, if a return is in a function, and it is not the last statement, that means there should have been some GOTO prior to run those latter instructions (early exit)
here, no gotos = one big happy block

=== @connorjclark (discord: connorclark) 01/06/2024 22:54

(replying to @EmilyV99 (discord: Emily) "and if the save file is re-lo…"): oh neat. I'm still not removing the NOPs btw, may not even be worth it
but good to know that would be handled already

=== @EmilyV99 (discord: Emily) 01/06/2024 22:56

(replying to @connorjclark (discord: connorclark) "normally, if a return is in a…"): Actually, RETURNFUNC only appears at the end of the function
An early return will GOTO the end of the function to hit that same RETURNFUNC
So, it always marks the end of the block

=== @connorjclark (discord: connorclark) 01/06/2024 22:57

oh, excellent

=== @EmilyV99 (discord: Emily) 01/06/2024 22:58

Because it like, does all the stack popping then
So needs to do that cleanup on any return
Also presumably where local array dealloc occurs

=== @connorjclark (discord: connorclark) 01/06/2024 22:59

does it hold that all functions emitted by the compiler end with GOTOR/RETURN/RETURNFUNC?
That means I don't have to hunt for function calls to construct the boundraries...

=== @EmilyV99 (discord: Emily) 01/06/2024 22:59

I'm pretty sure

=== @connorjclark (discord: connorclark) 01/06/2024 22:59

assuming nothing goes inbetweeen function ending and one starting

=== @EmilyV99 (discord: Emily) 01/06/2024 22:59

Given, I have never once worked on the internals of the parser when GOTOR was in use

=== @connorjclark (discord: connorclark) 01/06/2024 22:59

then the ends points could be used to construct the start points..

=== @EmilyV99 (discord: Emily) 01/06/2024 23:00

Aye, functions are the highest level block
There is nothing that *could* go between two funcs, aside from another func

=== @connorjclark (discord: connorclark) 01/06/2024 23:00

>     [stack] saved 1988974 instr (14.7%)
>     [total] saved 4010224 instr (29.6%)

new opt: removing pointless stack push/pops
that was larger than expected
yuurand

=== @EmilyV99 (discord: Emily) 01/06/2024 23:00

Oh, wait, I am wrong on one thing
Void run funcs
They tend to terminate in QUIT instead...
Which, can appear anywhere the user calls Quit() as well

=== @EmilyV99 (discord: Emily) 01/06/2024 23:02

As long as you account for those though, all other functions should follow the same pattern

=== @connorjclark (discord: connorclark) 01/06/2024 23:06

only yuurand really got huge savings for the stack opt. others were ~1%

=== @EmilyV99 (discord: Emily) 01/11/2024 03:23

(replying to @connorjclark (discord: connorclark) "does it hold that all functio…"): bah, I'm wrong
...not only was I wrong on void run funcs like I mentioned above
but, i forgot a recent optimization which makes it no longer true either
So, in the case of `GOTOR` and `RETURN`, it holds true except for void run funcs
but in the case of `RETURNFUNC`, it may have been optimized away by parser optimizations if it would have been unreachable
(as a function that *never returns* is something I detect)
(either terminating in an infinite loop with no `return`/`break`, or by calling another never-returning function, including the system functions `Quit()`, `Game->End()`, etc)

=== @connorjclark (discord: connorclark) 01/12/2024 08:14

added a pass to convert to modern calling mode
```
Finished optimizing scripts:
    [goto_next_instruction] saved 11813 instr (0.1%)
    [unreachable_blocks] saved 46143 instr (0.3%)
    [calling_mode] saved 495868 instr (3.7%)
    [conseq_additive] saved 124368 instr (0.9%)
    [loadi] saved 1129282 instr (8.3%)
    [setv_pushr] saved 255826 instr (1.9%)
    [setr_pushr] saved 228865 instr (1.7%)
    [stack] saved 1972470 instr (14.6%)
    [spurious_branches] saved 0 instr (0.0%)
    [reduce_comparisons] saved 266671 instr (2.0%)
    [unreachable_blocks_2] saved 3397 instr (0.0%)
    [dead_code] saved 252735 instr (1.9%)
    [total] saved 4787438 instr (35.3%)
```
yuurand

=== @EmilyV99 (discord: Emily) 01/12/2024 08:16

nice!!

=== @connorjclark (discord: connorclark) 01/12/2024 08:19

any reason sframe push/pop couldn't be part of function calling/returning command?
ideally we can just bump a zscript version and roll that into the existing newest commands instead of making yet new ones..

=== @EmilyV99 (discord: Emily) 01/12/2024 08:20

it doesn't know how many params were pushed
or something
idr
does that even affect it?
🤷‍♀️

=== @connorjclark (discord: connorclark) 01/12/2024 08:21

it could go on a separate stack like the return address does

=== @EmilyV99 (discord: Emily) 01/12/2024 08:21

however you think is best

=== @connorjclark (discord: connorclark) 01/12/2024 08:22

i'm actually not sure what would be best for jit...
i'll think on it more later

=== @EmilyV99 (discord: Emily) 01/12/2024 12:14

so, for the `script_variable variable_list`...

=== @EmilyV99 (discord: Emily) 01/12/2024 12:15

1. Do you think unrolling the *only 3* things that use the 'maxcount' feature, allowing entirely removing the maxcount field, would be worthwhile? That simplifies code in 3 separate places...

=== @EmilyV99 (discord: Emily) 01/12/2024 12:16

2. I should be able to denote "read-only" registers for some things, if that would be useful... could allow some optimization?
(registers which have no effect when written to)

=== @connorjclark (discord: connorclark) 01/13/2024 21:42

(replying to @EmilyV99 (discord: Emily) "1. Do you think unrolling the…"): yup!
(replying to @EmilyV99 (discord: Emily) "2. I should be able to denote…"): What's some examples of this?

=== @EmilyV99 (discord: Emily) 01/13/2024 21:44

idk

=== @connorjclark (discord: connorclark) 01/13/2024 21:44

I mean of a read only register

=== @EmilyV99 (discord: Emily) 01/13/2024 21:44

there are definitely some
not sure if they would come up often/at all
but like

=== @EmilyV99 (discord: Emily) 01/13/2024 21:46

`Game->DMapMap[]` is read-only
but the parser technically allows writing to it
which would produce setting the register `DMAPMAP`
...which, in ffscript, *does nothing*, as `case DMAPMAP:` is missing from `set_register`

=== @connorjclark (discord: connorclark) 01/13/2024 21:48

probably not worth it at this stage.

=== @EmilyV99 (discord: Emily) 01/13/2024 21:49

yeah, tiny thing

=== @connorjclark (discord: connorclark) 01/13/2024 21:49

oh, so this would be generalizing how D5/nul is handled

=== @EmilyV99 (discord: Emily) 01/13/2024 21:49

(replying to @connorjclark (discord: connorclark) "oh, so this would be generali…"): exactly

=== @connorjclark (discord: connorclark) 01/13/2024 21:49

I've got just one tiny thing that acknowledges that right now
in the POP -> POPARGs thingy

=== @EmilyV99 (discord: Emily) 01/13/2024 21:50

NUL is inherently a read-only register, as writing it has no effect

=== @connorjclark (discord: connorclark) 01/13/2024 21:50

should delete all the writes tho

=== @EmilyV99 (discord: Emily) 01/13/2024 21:50

also note that `BREAKPOINT NUL` has special meaning
...it does not read the value of the register, it instead treats it as `0`
(IIRC)

=== @connorjclark (discord: connorclark) 01/13/2024 21:54

that's the zasm debugger you mentioned never using right?

=== @EmilyV99 (discord: Emily) 01/13/2024 21:56

yep
used it a couple times lol

=== @connorjclark (discord: connorclark) 01/13/2024 23:01

now inlining some functions (only the simplest):

```
Function #0
    0: SETR            D4              SP           [Block 0 -> ]
    1: PUSHARGSR       D4              2
    2: LOADD           D2              70000
    3: PUSHR           D2
    4: CALLFUNC        43                           [Call Function #5]
    5: POP             D4
    6: PUSHR           D2
    7: PUSHR           D4
    8: LOADD           D2              70000
    9: PUSHR           D2
   10: CALLFUNC        32                           [Call Function #3]
   11: POP             D4
   12: PUSHR           D2
   13: PUSHR           D4
   14: CALLFUNC        24                           [Call Function #1]
   15: POP             D4
   16: PUSHR           D2
   17: PUSHR           D4
   18: CALLFUNC        28                           [Call Function #2]
   19: POP             D4
   20: PUSHR           D2
   21: CALLFUNC        37                           [Call Function #4]
   22: POP             D4
   23: QUIT


Function #1
   24: SETR            D4              SP           [Block 0 -> ]
   25: SETR            D2              LINKX
   26: ADDV            D2              80000
   27: RETURNFUNC


Function #2
   28: SETR            D4              SP           [Block 0 -> ]
   29: SETR            D2              LINKY
   30: ADDV            D2              80000
   31: RETURNFUNC


Function #3
   32: SETR            D4              SP           [Block 0 -> ]
   33: POP             D2
   34: TRACER          D2
   35: TRACEV          1
   36: RETURNFUNC


Function #4
   37: POP             D2                           [Block 0 -> ]
   38: POP             D1
   39: POP             D0
   40: POP             D6
   41: SETR            D2              DISTANCE
   42: RETURNFUNC


Function #5
   43: SETR            D0              LINKX        [Block 0 -> ]
   44: TRACER          D0
   45: TRACER          D0
   46: RETURNFUNC


= expected

rewrite 13: 3 -> 2 commands
13: SETR            D2              LINKX  
14: ADDV            D2              80000  
15: NOP            
rewrite 17: 3 -> 2 commands
17: SETR            D2              LINKY  
18: ADDV            D2              80000  
19: NOP            
Function #0
    0: SETR            D4              SP           [Block 0 -> ]
    1: PUSHARGSR       D4              2
    2: LOADD           D2              70000
    3: PUSHR           D2
    4: CALLFUNC        43                           [Call Function #3]
    5: POP             D4
    6: PUSHR           D2
    7: PUSHR           D4
    8: LOADD           D2              70000
    9: PUSHR           D2
   10: CALLFUNC        32                           [Call Function #1]
   11: POP             D4
   12: PUSHR           D2
   13: SETR            D2              LINKX
   14: ADDV            D2              80000
   15: NOP
   16: PUSHR           D2
   17: SETR            D2              LINKY
   18: ADDV            D2              80000
   19: NOP
   20: PUSHR           D2
   21: CALLFUNC        37                           [Call Function #2]
   22: POP             D4
   23: QUIT
   24: NOP
   25: NOP
   26: NOP
   27: NOP
   28: NOP
   29: NOP
   30: NOP
   31: NOP


Function #1
   32: NOP                                          [Block 0 -> ]
   33: POP             D2
   34: TRACER          D2
   35: TRACEV          1
   36: RETURNFUNC


Function #2
   37: POP             D2                           [Block 0 -> ]
   38: POP             D1
   39: POP             D0
   40: POP             D6
   41: SETR            D2              DISTANCE
   42: RETURNFUNC


Function #3
   43: SETR            D0              LINKX        [Block 0 -> ]
   44: TRACER          D0
   45: TRACER          D0
   46: RETURNFUNC
```

=== @connorjclark (discord: connorclark) 01/13/2024 23:02

currently limited to functions that use no more than 1 parameter, and only do one instruction of work.

=== @connorjclark (discord: connorclark) 01/13/2024 23:03

which, for yuurand...

> [inline_functions] saved 63223 instr (0.5%)
the impact is larger than "instructions reduced" really captures

=== @EmilyV99 (discord: Emily) 01/13/2024 23:47

I have a couple of fancy fancy ideas for stuff

=== @EmilyV99 (discord: Emily) 01/13/2024 23:56

1. Reworking global variables (deprecating `gd0 - gd1023` registers). Probably add a couple opcodes specifically for working with global vars, and in doing this, *drastically* increase the global variable max from 1024 to... idk, maybe 100,000? It'll only use space for as many as the user uses, so the point is that it's higher than will realistically be ever hit.

=== @EmilyV99 (discord: Emily) 01/13/2024 23:58

2. The branch I had going for merging all the quest's ZASM, no longer having separate script slots. Probably needs a fair bit of updating to meet `main` again, plus whatever handling for jit stuff that wasn't done there.

=== @EmilyV99 (discord: Emily) 01/14/2024 00:01

3. In said branch, slight new idea; DON'T merge all the quest's zasm into *only 1* slot. Instead, allow the user to increase the number of 'slots', and compile into an arbitrary one of them. This would fix, for example, the edge case of someone losing their scripts- they could  leave their missing scripts in the slot they were previously compiled in, but can still add newly compiled scripts by adding them in a separate slot.
(most quests would likely only have 1 slot, but multiple would be supported)
(and, as before, each slot would contain more than one script, with each script pointing to a specific slot and line number of its' void run)

=== @connorjclark (discord: connorclark) 01/14/2024 06:37

multiple slots =  the player will have to merge it into a single slot at runtime? since we need one contiguous block of instructions.

Would being able to extract a qst's ZASM into a big `.zasm` blob, and able to import it back ... (either set in the editor compilation "include this zasm too", or via script like ... `import 'blob.zasm'`...) be simpler?

=== @connorjclark (discord: connorclark) 01/14/2024 06:38

Keeping globals as registers is a very nice thing, it'd be harder to track as like, `SETGLOBAL 0 D3` or whatever.
how do arrays work?

=== @connorjclark (discord: connorclark) 01/14/2024 06:39

ah, `READPODARRAYR`
so given there's already arrays, I'd already have to support life time analysis for elements within arrays, so I guess keeping globals in something array like isn't any additional complexity

=== @connorjclark (discord: connorclark) 01/14/2024 06:46

is the main goal to allow for more globals? what about just setting aside `0x40000-0x80000` to do the same?

=== @EmilyV99 (discord: Emily) 01/14/2024 08:18

allowing more globals is a big nice, yeah
and it also will use less space (memory and quest file size) if less of them are used, since it can be variably sized instead of `[1024]`
think I have that mostly done

=== @EmilyV99 (discord: Emily) 01/14/2024 08:22

(replying to @connorjclark (discord: connorclark) "multiple slots =  the player…"): So, the idea here in total is:
- No longer does each script have a 'slot' (entire set of ZASM per-script). Multiple scripts share a single slot, referencing the start of their void run as a line number.
- Scripts which share a slot can share functions and the like, which reduces complexity. For 99% of use cases, users will only need one 'slot', which will contain all of their scripts.
- Users can opt to add additional slots, which are separate blocks of instructions and are treated completely separately (similar to how separate script slots are separate now). This is mostly useful in the specific edge case that they lost their scripts, and thus if they recompile over the existing 'slot', they will lose the ZASM from their missing scripts- but by compiling in a separate slot, they can add new scripts without interfering or interacting with the old scripts.
Additionally, each slot would have its' own set of globals- it could could the number of globals each slot uses, and offset based on that.

=== @connorjclark (discord: connorclark) 01/14/2024 08:23

(replying to @EmilyV99 (discord: Emily) "think I have that mostly done"): but it doesn't necessitate no longer being registers - are you going with expanding `GD` or making a new op for globals?

=== @EmilyV99 (discord: Emily) 01/14/2024 08:24

(replying to @connorjclark (discord: connorclark) "but it doesn't necessitate no…"): well if I wanted to unroll the script_var table, expanding GD would take quite a lot of work...

=== @connorjclark (discord: connorclark) 01/14/2024 08:24

The nice thing about registers is they plug into any op. The zscript compiler isn't doing this, but I very well could begin inlining any non-D registers right into like, ADDV or whatever

=== @EmilyV99 (discord: Emily) 01/14/2024 08:24

(replying to @connorjclark (discord: connorclark) "The nice thing about register…"): aye, but I figure for global variables it's worth using a separate system more like arrays

=== @connorjclark (discord: connorclark) 01/14/2024 08:24

But if you must use another op to load into a D, then operate, then set back into D, that is overhead

=== @connorjclark (discord: connorclark) 01/14/2024 08:27

> This is mostly useful in the specific edge case that they lost their scripts, and thus if they recompile over the existing 'slot', they will lose the ZASM from their missing scripts- but by compiling in a separate slot, they can add new scripts without interfering or interacting with the old scripts.

You've repeated the same edge case as the only justification for this. I'm not seeing it as worth it. Can we solve this edge case in another way? Does it really happen often enough to justify complicating the entire thing? One single "slot" seems too nice a thing to give up just for this. See my suggestion about exporting/importing raw ZASM.

=== @EmilyV99 (discord: Emily) 01/14/2024 08:28

🤷‍♀️ other people have repeated the same edge case at me

=== @connorjclark (discord: connorclark) 01/14/2024 08:34

btw slot now = which index a script goes into (ffc index 1 is a slot, etc). we still need to map script entries in the same way, right? but now "slot" becomes a new concept (separate chunks of instructions)?
did slot just become overloaded or am I missing something?

=== @EmilyV99 (discord: Emily) 01/14/2024 08:35

'slot' has meant 2 things, which mostly were the same thing
...now they don't mostly mean the same thing anymore
....If we did this we'd need a better term

=== @connorjclark (discord: connorclark) 01/14/2024 08:43

If that edge case is really the only reason to have multiple slots, it seems much simpler to offer a way to export a qst's ZASM to re-import. Or maybe even simpler-- when the editor is compiling and notices there are existing scripts that no longer exist in the compiler's output, offer to "carry forward" those scripts into the final, single slot of instructions saved into the qst. Would that be the equivalent outcome, keeping the ability to use scripts that can no longer be compiled from source?

If we can avoid adding a new concept of slots to the editor GUI, that seems very worth it. And for the player, it'll be slightly nicer if we can reference scripts with just a `pc` offset, instead of `(slot index, pc)`.

=== @EmilyV99 (discord: Emily) 01/14/2024 08:43

> Would that be the equivalent outcome, keeping the ability to use scripts that can no longer be compiled from source?
...yes.

=== @connorjclark (discord: connorclark) 01/18/2024 00:11

I'm introducing some new stuff to improve performance of every stack read/write. The goal is to remove the division by 10000.

SP2: returns ri->sp, without multiplying by 10000
LOAD/STORE: same as LOADD,/STORED but arg2 is used directly as the offset (instead of arg2/10000)

=== @EmilyV99 (discord: Emily) 01/18/2024 00:15

neat

=== @connorjclark (discord: connorclark) 01/18/2024 09:05

difference for the x64 jit:

```asm
mov ecx, 0                                  ; 32 LOADD           D2              0
add ecx, dword ptr [rdi+16]
movsxd rax, ecx
sar ecx, 31
imul rax, rax, 1759218605
sar rax, 44
sub eax, ecx
mov ecx, eax
mov eax, dword ptr [rbp+ecx*4]
mov dword ptr [rdi+8], eax
mov eax, dword ptr [rdi+8]                  ; 33 ADDV            D2              10000
add eax, 10000
mov dword ptr [rdi+8], eax
mov ecx, 0                                  ; 34 STORED          D2              0
add ecx, dword ptr [rdi+16]
movsxd rax, ecx
sar ecx, 31
imul rax, rax, 1759218605
sar rax, 44
sub eax, ecx
mov ecx, eax
mov eax, dword ptr [rdi+8]
mov dword ptr [rbp+ecx*4], eax
```

to

```asm
mov eax, dword ptr [rdi+16]                 ; 32 LOAD            D2              0
mov eax, dword ptr [rbp+eax*4]
mov dword ptr [rdi+8], eax
mov eax, dword ptr [rdi+8]                  ; 33 ADDV            D2              10000
add eax, 10000
mov dword ptr [rdi+8], eax
mov ecx, 0                                  ; 34 STORE           D2              0
add ecx, dword ptr [rdi+16]
mov eax, dword ptr [rdi+8]
mov dword ptr [rbp+ecx*4], eax
```

=== @EmilyV99 (discord: Emily) 01/18/2024 09:07

WOW
das fancy

=== @connorjclark (discord: connorclark) 01/18/2024 09:12

something like ~20% fewer instructions, judging by random scripts from yuurand

=== @EmilyV99 (discord: Emily) 01/18/2024 09:13

nicee

=== @connorjclark (discord: connorclark) 01/19/2024 21:38

another opt I'm working on - using a register more directly (without first setting to a D reg, for example SETR D2 LINKX; TRACER D2 -> TRACER LINKX). including when pushed to stack and pop'd later. Only possible when register in question is not possibly modified between the original setting to a D reg and the actual usage (so a write - or even any function call - invalidates this opt)
but I think I want to only do it if the register is used _once_, not any more than that
as D-regs (and GD,  etc) are much cheaper to access than any other, _especially_ in the compiled x64 assembly.
in other words, inlining registers when possible but without increasing number of calls to `get_register`
so `SETR D2 LINKX; TRACER D2; TRACER D2` would not change, for example

=== @EmilyV99 (discord: Emily) 01/19/2024 23:06

neat, makes total sense

=== @connorjclark (discord: connorclark) 01/19/2024 23:26

ahh but now i need a list of commands that read from stack

=== @EmilyV99 (discord: Emily) 01/19/2024 23:27

ahh, oof
true
....that's a lot

=== @connorjclark (discord: connorclark) 01/20/2024 09:20

is `FFScript::do_npc_add` setting two register outputs a mistake?

=== @connorjclark (discord: connorclark) 01/20/2024 23:32

SETSCREENENEMY
SETSCREENDOOR

These are register macros but they are in the run_script_int command switch

=== @EmilyV99 (discord: Emily) 01/20/2024 23:34

wtf

=== @EmilyV99 (discord: Emily) 01/20/2024 23:38

(replying to @connorjclark (discord: connorclark) "is `FFScript::do_npc_add` set…"): No, because that function does something fucking cursed
It returns the d1
But the d2, it *writes to the pointer it was called on*
So ```cpp
npc n;
n->Create();
Trace(n->X);```
n stops being null thanks to the d2 output being reassigned to "n"

=== @connorjclark (discord: connorclark) 01/21/2024 04:16

shitttttt
remember a year ago you fixed SDDDD
```
Function #57
62191: POP             D6                           [Block 0 -> ]
62192: POP             D1                           
62193: POP             D0                           
62194: POP             D5                           
62195: SETR            D2              SDDDD        
62196: POP             D3                           
62197: GOTOR           D3                           
```
this is a function of zasm in "Mirage Island"
gets called like ....

```
36140: SETV            D2              70000        
36141: PUSHR           D2                           
36142: GOTO            62191                        [Call Function #57]
```

=== @EmilyV99 (discord: Emily) 01/21/2024 04:17

it's out of boundsing the array isn't it

=== @connorjclark (discord: connorclark) 01/21/2024 04:17

...but I have an opt that would change the above to PUSHV 70000
so, not set D2
which the function inadvertantly uses
of course its wrong either way but,
this means a replay recorded w/o opts differs to one with opts, which is what I really want to avoid
so I need to somehow detect this

=== @connorjclark (discord: connorclark) 01/21/2024 04:19

and it actually causes the randomizer to just hang when "optimized"

=== @EmilyV99 (discord: Emily) 01/21/2024 04:19

oof
Hand Zasm is a problem

=== @connorjclark (discord: connorclark) 01/21/2024 04:21

I don't think any handwrittens ZASM exists in published quests break from anything I've done yet. and I want to say we just don't support arbirtary zasm, just what the compiler has emitted at some point.
that way I've been able to assume "calling a function invalidates all registers, AKA function wont ever read a register before writing to it"
...except when there was a bug in the compiler that made that not true, like here.

=== @EmilyV99 (discord: Emily) 01/21/2024 04:22

yeah, oof
...could just disable optimizations for scripts containing SDDDD?
/ any other similarly broken opcodes if such exists

=== @connorjclark (discord: connorclark) 01/21/2024 06:39

Did something like that. disabling opt for function (or any that call it) if SDDDD is used, and I find that D2 is possibly uninitialized

=== @connorjclark (discord: connorclark) 01/24/2024 00:05

this is what is optimized out of current output of compiler (playground.qst)

```
Finished optimizing scripts:
        [calling_mode] saved 0 instr (0.0%), took 0 ms
        [inline_functions] saved 12 instr (0.1%), took 0 ms
        [goto_next_instruction] saved 0 instr (0.0%), took 0 ms
        [unreachable_blocks] saved 36 instr (0.2%), took 5 ms
        [conseq_additive] saved 0 instr (0.0%), took 0 ms
        [load_store] saved 0 instr (0.0%), took 0 ms
        [setv_pushr] saved 591 instr (3.4%), took 0 ms
        [setr_pushr] saved 292 instr (1.7%), took 0 ms
        [stack] saved 118 instr (0.7%), took 0 ms
        [spurious_branches] saved 0 instr (0.0%), took 4 ms
        [reduce_comparisons] saved 790 instr (4.6%), took 4 ms
        [propagate_values] saved 188 instr (1.1%), took 9 ms
        [unreachable_blocks_2] saved 66 instr (0.4%), took 0 ms
        [dead_code] saved 281 instr (1.6%), took 4 ms
        [total] saved 2374 instr (13.7%), took 34 ms
```

may create a common library for this and call it at end of compilation. but later, when more sure of its correctness
