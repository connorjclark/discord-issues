## âŒLayered Lock Blocks Don't Work by Default (#2934)
@connorjclark (discord: connorclark) opened this issue on 12/26/2023
Status: unknown
Tags: Closed,Fixed
Source: #bug-reports https://discord.com/channels/876899628556091432/1189307068553891940


=== @connorjclark (discord: connorclark) 12/26/2023 20:41

Given:

```
if (a > 10 && a < 20 && a != 14 && a != 16)
{
    Trace(1);
}
else if (a > 15 && a <= 30)
{
    Trace(2);
}
Trace(0);
```

The ZASM is:

```
Function #7
  144: SETR            D4              SP           [Block 0 -> 1, 2]
  145: LOADD           D2              0            
  146: COMPAREV        D2              100000       
  147: SETCMP          D2              >            
  148: COMPAREV        D2              0            
  149: GOTOTRUE        153                          
  150: LOADD           D2              0            [Block 1 -> 2]
  151: COMPAREV        D2              200000       
  152: SETCMP          D2              <            
  153: COMPAREV        D2              0            [Block 2 -> 3, 4]
  154: SETCMP          D2              !=           
  155: COMPAREV        D2              0            
  156: GOTOTRUE        160                          
  157: LOADD           D2              0            [Block 3 -> 4]
  158: COMPAREV        D2              140000       
  159: SETCMP          D2              !=           
  160: COMPAREV        D2              0            [Block 4 -> 5, 6]
  161: SETCMP          D2              !=           
  162: COMPAREV        D2              0            
  163: GOTOTRUE        167                          
  164: LOADD           D2              0            [Block 5 -> 6]
  165: COMPAREV        D2              160000       
  166: SETCMP          D2              !=           
  167: COMPAREV        D2              0            [Block 6 -> 7, 8]
  168: SETCMP          D2              !=           
  169: COMPAREV        D2              0            
  170: GOTOTRUE        173                          
  171: TRACEV          10000                        [Block 7 -> 12]
  172: GOTO            186                          
  173: LOADD           D2              0            [Block 8 -> 9, 10]
  174: COMPAREV        D2              150000       
  175: SETCMP          D2              >            
  176: COMPAREV        D2              0            
  177: GOTOTRUE        181                          
  178: LOADD           D2              0            [Block 9 -> 10]
  179: COMPAREV        D2              300000       
  180: SETCMP          D2              <=           
  181: COMPAREV        D2              0            [Block 10 -> 11, 12]
  182: SETCMP          D2              !=           
  183: COMPAREV        D2              0            
  184: GOTOTRUE        186                          
  185: TRACEV          20000                        [Block 11 -> 12]
  186: TRACEV          0                            [Block 12 -> ]
  187: POP             D5                           
  188: RETURNFUNC                                   
```

For every portion of `a > 10 && a < 20 && a != 14 && a != 16`, each expression is evaluated, then negated. if it fails the check it jumps to the next expression's portion of the zasm, which also is a weirdly inefficient 4 ops (see the first jump from 149 to 153). If I'm reading this right, even if something fails a check early on it will jump to each sub expression's check, reusing the failure state of that check until it finall gets to the block after the entire conditional.

=== @connorjclark (discord: connorclark) 12/26/2023 20:43

This is in every single compiled quest, so in my goal to improve all existing quests I'm gonna try to unwind this logic. I've made some progress.

but just fyi, in case @EmilyV99 (discord: Emily) you are interested in improving the output of the compiler - the output for COMPARE stuff is very convoluted atm

=== @connorjclark (discord: connorclark) 12/26/2023 20:48

Some specific examples of possible improvements:


1. Negate the SETCMP directly, instead of using COMPAREV 0
```
  146: COMPAREV        D2              100000       
  147: SETCMP          D2              >            
  148: COMPAREV        D2              0            

=>

  146: COMPAREV        D2              100000       
  147: SETCMP          D2              <=            
```

2. Jump to the end of the expression when part of the expression fails/short-circuits
```
  146: COMPAREV        D2              100000       
  147: SETCMP          D2              >            
  148: COMPAREV        D2              0            
  149: GOTOTRUE        153                          

=>

  146: COMPAREV        D2              100000       
  147: GOTOCMP         173             <=            
```
I've managed these with some success so far in the zplayer optimizer.

=== @EmilyV99 (discord: Emily) 12/26/2023 20:59

(replying to @connorjclark (discord: connorclark) "Some specific examples of posâ€¦"): so, not much I see here for the compiler to improve on, due to recursion
because like, the `&&` short-circuiting
is `(Visit Left) != 0` that it's `COMPAREV d2,0`'ing
so, it doesn't know what's inside it

=== @connorjclark (discord: connorclark) 12/26/2023 21:00

you have the AST at the end, which is when you'd apply these sorts of opts, if not possible earlier I suppose.
or maybe we need higher level ast nodes for these things?

=== @EmilyV99 (discord: Emily) 12/26/2023 21:01

```cpp
void BuildOpcodes::caseExprGT(ASTExprGT& host, void* param)
{
    if (auto v = host.getCompileTimeValue(this, scope))
    {
        CONST_VAL(*v);
        return;
    }
    SIDEFX_BINOP();
    
    bool decret = *lookupOption(*scope, CompileOption::OPT_BOOL_TRUE_RETURN_DECIMAL)!=0;
    compareExprs(host.left.get(), host.right.get(), param);
    auto cmp = CMP_GT;
    if(!decret)
        cmp |= CMP_SETI;
    addOpcode(new OSetCompare(new VarArgument(EXP1), new LiteralArgument(cmp)));
}```
so like, this here is doing `x > y` and `SETCMP`'ing, and that's the entirety of what a `ASTExprGT` generates
...hmm

=== @connorjclark (discord: connorclark) 12/26/2023 21:02

It seems normal to me that these optimizations can't be done locally. But you've got the entire context of the program in an AST to work with in optimization passes.

=== @EmilyV99 (discord: Emily) 12/26/2023 21:03

(replying to @connorjclark (discord: connorclark) "It seems normal to me that thâ€¦"): none of the optimization passes at the end use the AST at all
they are done on the ZASM output

=== @connorjclark (discord: connorclark) 12/26/2023 21:03

that's a huge constraint - why?

=== @EmilyV99 (discord: Emily) 12/26/2023 21:03

...uhh
well at that point the ZASM is generated
and there's no link back to the AST

=== @connorjclark (discord: connorclark) 12/26/2023 21:04

gotcha - ok then why no optimization pass before the AST emits the zasm

=== @EmilyV99 (discord: Emily) 12/26/2023 21:04

that's what's subject to said recursion
so, I would need the optimization to work within the recursive framework
...which, might be doable?
I gave `ASTExprNot` the premise of being 'inverted', which handles things like double-negatives

=== @connorjclark (discord: connorclark) 12/26/2023 21:05

it should certainly be doable. I'm nearly done with it with just looking at the unstructured zasm, and I'm not inventing any information that isn't already there but more accessible in the AST.

=== @EmilyV99 (discord: Emily) 12/26/2023 21:05

I should be able to give a similar concept to all the relational nodes, flipping their sign `<` -> `>=` and etc
and then have a virtual bool func `isInvertable()`, so that things like the `ASTExprAnd` can make use of this optimization
then I need to code the appropriate logic in for short circuiting there, and probably also for `if`/`unless` stuff for additional optimization
...this will take a lot of parser work energy, which I've completely burned myself out of, soo

=== @connorjclark (discord: connorclark) 12/26/2023 21:09

It's not so important if I'm able to do the same at runtime. It'd surely be faster if the ZASM was already opt'd in this way beforehand (fixing compares seem the most expensive process so far), so at best it'd be good for slightly faster optimizing.... assuming you don't find a way to optimize it further than I can looking at just the zasm

=== @EmilyV99 (discord: Emily) 12/26/2023 21:11

the fun thing is there's already a bunch of optimizations tangled here for compile-time constant values
like, `x && true` is really just `x`, with the value forced to boolean
and `x < 2` / `2 < x` can use `COMPAREV`/`COMPAREV2` instead of `COMPARER`
...hmm, it does mostly boil down to the one block at the end for what would need changing, though

![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189315136767410246/image.png?ex=65e78b09&is=65d51609&hm=e5948499a84cdf3489d2833dfef3d6e6190af1a16326c7a5e3c3f84d8299cf20&)
so for `And`, this here...

=== @connorjclark (discord: connorclark) 12/26/2023 21:14

also fyi, i've been able to strip all the CMP_SETI in my opt passes and nothing seems to have broken..
at least, for compare/conditionals. idk it SETCMP is used for simply setting a register for non compare purposes.

=== @EmilyV99 (discord: Emily) 12/26/2023 21:15

`SETCMP` will be the last opcode of any `<`, `>`, `<=`, `>=`, `==`, `!=` operator
and used in `~~` (approx-equal) and `^^` (bool XOR)
and `&&`, `||`, `!`
(replying to @connorjclark (discord: connorclark) "also fyi, i've been able to sâ€¦"): `CMP_SETI` will break things if people use the int value of a boolean
basically, is `<int>(x > 2)  + <int>(y < 5)` a value of `0, 1, 2` or `0, 0.0001, 0.0002`
is what that deals with

=== @connorjclark (discord: connorclark) 12/26/2023 21:18

so if attached to an assignment it may matter
but not `if (... )` afaict
or passed to a fn i guess

=== @EmilyV99 (discord: Emily) 12/26/2023 21:18

aye, if it's just being compared to 0 for a conditional, it should be safe to trim
but it could be in a deeper condition
imagine `if(<int>(x>2) + <int>(y<5) + <int>(z==0) < 2)`
...weird-ass code, but per our specifications, should be valid
and here the results of `x>2`, `y<5`, and `z==0` would need the `CMP_SETI` to work
or this condition would never evaluate *false*, as it would always be `0, 0.0001, 0.0002, 0.0003`, which are all `< 2`
definitely edge-case stuff

=== @connorjclark (discord: connorclark) 12/26/2023 21:30

could that be solved with a isLegacyIntsRequired virtual function lol
idk if nodes can access their calling context to query parents for that ..

=== @EmilyV99 (discord: Emily) 12/26/2023 21:32

knowing parents is not really doable

=== @connorjclark (discord: connorclark) 12/26/2023 21:33

Prob not worth it. This and things like no real ints / types are just begging for a one time big language change (with a version indicator at top opt in...) ... But that's getting off topic

=== @EmilyV99 (discord: Emily) 12/26/2023 21:33

you would need to store the context somehow specifically

=== @EmilyV99 (discord: Emily) 12/26/2023 21:39

wait, am I fucking stupid?
...bleh, *dumbass* this is simpler than I was making it
...I can just check that after visiting the sub-argument, *is the latest opcode an `OSetCompare`*?

=== @EmilyV99 (discord: Emily) 12/26/2023 21:47

so basically
```cpp
visit(host.left.get(), param);
//Check left, skip if false
addOpcode(new OCompareImmediate(new VarArgument(EXP1), new LiteralArgument(0)));
addOpcode(new OGotoTrueImmediate(new LabelArgument(skip)));
```
->
```cpp
visit(host.left.get(), param);
if(OSetCompare* setcmp = dynamic_cast<OSetCompare*>(backOpcode()))
{
    auto cmp = static_cast<LiteralArgument*>(setcmp->getSecondArgument())->value;
    cmp &= ~CMP_SETI; //never needed inside a bool op
    backTarget().pop_back(); //erase the OSetCompare
    addOpcode(new OGotoCompare(new LabelArgument(skip), new LiteralArgument(INVERT_CMP(cmp))));
}
else
{
    //Check left, skip if false
    addOpcode(new OCompareImmediate(new VarArgument(EXP1), new LiteralArgument(0)));
    addOpcode(new OGotoTrueImmediate(new LabelArgument(skip)));
}```

=== @EmilyV99 (discord: Emily) 12/26/2023 21:50

..also, `And` and `Or` themselves end in `OSetCompare`, so chaining multiple `And`/`Or` will also benefit from this.
so this should be pretty optimal

=== @connorjclark (discord: connorclark) 12/26/2023 22:01

Glad you found a nice solution.

=== @EmilyV99 (discord: Emily) 12/26/2023 22:01

...except, fuck
when it skips to the end, it was hitting ANOTHER `OSetCompare`... and reusing the same compare information?

=== @connorjclark (discord: connorclark) 12/26/2023 22:02

Yup.

=== @EmilyV99 (discord: Emily) 12/26/2023 22:02

bleh
this doesn't work then
because now the compare info won't match up

=== @connorjclark (discord: connorclark) 12/26/2023 22:02

That's why I mentioned it should jump to the end of them, not the next in the chain
At that point it will just keep jumping til the end of it

=== @EmilyV99 (discord: Emily) 12/26/2023 22:03

(replying to @connorjclark (discord: connorclark) "That's why I mentioned it shoâ€¦"): you say "the end of them"

=== @connorjclark (discord: connorclark) 12/26/2023 22:03

Reusing compare all the way down

=== @EmilyV99 (discord: Emily) 12/26/2023 22:03

each of these is a single binary operation
between two operands
it doesn't know about any more

=== @connorjclark (discord: connorclark) 12/26/2023 22:03

sad
can multiple conditional binary ops be pulled up into a new ast node ---shirt circuit node?? Idk if that makes any sense
Then that node would know how to do it proper

=== @EmilyV99 (discord: Emily) 12/26/2023 22:04

possibly, this would be designing something brand new
could have a pass that parses through boolean ops and replaces them with these combined nodes

=== @connorjclark (discord: connorclark) 12/26/2023 22:05

Anyhow I'm starting to get why the ZASM is so suboptimal.
Yeah, that
Adjacent Boolean ops get made into a new node
And if any fail their condition then it jumps to the end of all of them
The individual binary ops need to be separated by AND
I guess you wanna do or too for the inverse duh
I actually haven't analyzed the output of OR in the ZASM yet

=== @EmilyV99 (discord: Emily) 12/26/2023 22:07

a `vector<vector<Expr>>` would probably work

=== @connorjclark (discord: connorclark) 12/26/2023 22:07

it' prob exactly the same crazy amount of extra jumping

=== @EmilyV99 (discord: Emily) 12/26/2023 22:07

for each vector,
- visit each expr, if fails, skip to next vector
so like, either inner or outer would be `&&`, other `||`

=== @EmilyV99 (discord: Emily) 12/26/2023 22:10

`a || b && c || d` ->```
visit(a)
true -> c
visit(b)
false -> end (false)
c: visit(c)
true -> end (true)
visit(d)
false -> end(false)
end(true): set d2 to 10000 or 1
goto -> end
end(false): set d2 to 0
end: nop```
does that like, make sense?

=== @EmilyV99 (discord: Emily) 12/26/2023 22:14

more complexly

=== @EmilyV99 (discord: Emily) 12/26/2023 22:16

`(a || b || c) && (d || e || f) && (g || h || i)` -> ```
visit(a)
true -> d
visit(b)
true -> d
visit(c)
false -> ret_false
d: visit(d)
true -> g
visit(e)
true -> g
visit(f)
false -> ret_false
g: visit(g)
true -> ret_true
visit(h)
true -> ret_true
visit(i)
false -> ret_false
ret_true: set d2 to 10000 or 1
goto -> end
ret_false: set d2 to 0
end: nop
```
...extending for an arbitrary number of pairs

=== @connorjclark (discord: connorclark) 12/26/2023 22:16

Yeah it does

Only thing is still we have a SET at the end, then a compare/GOTOCMP for branching - when most optimal would be ignoring setting d2 at end and somehow wire in the node to jump to next instead

I get why it does the set currently, as it is used for more than just branching

=== @EmilyV99 (discord: Emily) 12/26/2023 22:17

I was chopping out a lot of the SETCMPs
all of those `true ->` / `false ->` would be `GOTOCMP`s based on the arg

=== @connorjclark (discord: connorclark) 12/26/2023 22:17

Yeah you got em all in the short circuiting but I mean that the result of this, when used for branching, still need to turn the D2 into a compare/GOTOCMP pair

=== @EmilyV99 (discord: Emily) 12/26/2023 22:18

for a var represeting `x > 2`, `true->` would imply `CMP_GT`, while `false->` would imply `CMP_LE`

=== @connorjclark (discord: connorclark) 12/26/2023 22:18

Maybe better to solve in a ZASM post process ...
It's pretty simple to detect

=== @EmilyV99 (discord: Emily) 12/26/2023 22:18

any expression visited always sets into `d2` by the end
because that's how the recursion is defined

=== @connorjclark (discord: connorclark) 12/26/2023 22:18

gotcha

=== @EmilyV99 (discord: Emily) 12/26/2023 22:19

what I can optimize here is, if the latest opcode is `SETCMP`, I can just *eat* that opcode, removing it and using the compare-type it was set to for a new opcode
because, while I don't have normal access outside the recursion, I *do* have access to the ZASM output so far
which was the big *oh, duh, I'm a dumbass* moment earlier
...so, now what I need, is a new *AST Optimization Pass*
I'll probably put that *after* the `ReturnVisitor`
and it'll be designed around the premise of replacing some AST with other AST
can have an `optional<AST*>` passed as the `void* param`, and use that as a "return" for each visited node for what to replace it with, if anything
and the `visit` overload can then handle actually replacing that

=== @EmilyV99 (discord: Emily) 12/26/2023 22:23

...then I need for this optimization, to create a new `ASTExprBoolCombined`, which holds a set of `ASTExprAnd` and `ASTExprOr` in some manner
.....now, the specific layout I did before, actually only works 2-deep....
i.e. it can't handle `(a && b) || (c && (d || e))`
because `||` in `&&` in `||` is 3-deep
so, I'd need actually to have a *recursive* chain
flipping between `&&` and `||` at each step
....and yeah that's about all the brain I have for this tonight lol

=== @EmilyV99 (discord: Emily) 12/27/2023 02:42

first compile attempt, parser crashes at pass 6. Now for debug time.

=== @EmilyV99 (discord: Emily) 12/27/2023 02:49

...I forgot a null check, now zscript compiles. Time to see if it makes sense lol.

=== @EmilyV99 (discord: Emily) 12/27/2023 02:50

And, yeah, nope, of course, broken. Bleh.

=== @EmilyV99 (discord: Emily) 12/27/2023 03:02

dumb typos are fun lol

=== @EmilyV99 (discord: Emily) 12/27/2023 03:13

oh, also GOTOCMP was missing some of the optimizations I had for other GOTO types

=== @EmilyV99 (discord: Emily) 12/27/2023 03:15

@connorjclark (discord: connorclark) do you think it would be better if the parser only emitted `GOTOCMP`/`SETCMP` instead of the various `GOTOTRUE`/`GOTOFALSE`/etc etc? (as far as, would that be cleaner for optimizations on your end or such?)
(if so, should be simple enough at the optimization pass to replace all of the old types)

=== @connorjclark (discord: connorclark) 12/27/2023 03:15

Not any cleaner. I have to handle old scripts anyway.
Do what is simplest

=== @EmilyV99 (discord: Emily) 12/27/2023 03:16

fair
wondering if it'll help on my end any...
could in theory, but, not sure in practice, so not something to bother with yet at least

=== @EmilyV99 (discord: Emily) 12/27/2023 03:20

OK

=== @EmilyV99 (discord: Emily) 12/27/2023 03:37

WOO
results
are had

=== @EmilyV99 (discord: Emily) 12/27/2023 03:38

For the code:```cpp
void run()
{
    int a,b,c,d,e,f,g,h,i;
    a = 1; b = 2;
    TraceB(a && b && (c || d) && e);
}```
previously:```cpp
 PUSHARGSV 0,0.0006; void run() Body Start
 SETR d4,SP
 SETV d2,1
 STORED d2,4
 SETV d2,2
 STORED d2,3
 LOADD d2,4; InlineFunc[void TraceB(bool)] Params Start
 COMPAREV d2,0
 GOTOTRUE 11
 LOADD d2,3
 COMPAREV d2,0
 SETCMP d2,0.0011
 COMPAREV d2,0
 GOTOTRUE 21
 LOADD d2,2
 COMPAREV d2,0
 GOTOFALSE 20
 LOADD d2,1
 COMPAREV d2,0
 SETCMP d2,0.0003
 COMPAREV d2,0
 SETCMP d2,0.0011
 COMPAREV d2,0
 GOTOTRUE 26
 LOADD d2,0
 COMPAREV d2,0
 SETCMP d2,0.0011; InlineFunc[void TraceB(bool)] Params End
 TRACE2R d2; InlineFunc[void TraceB(bool)] Body
 POPARGS d5,0.0006
 QUIT; void run() Body End
```
new:```cpp
 PUSHARGSV 0,0.0006; void run() Body Start
 SETR d4,SP
 SETV d2,1
 STORED d2,4
 SETV d2,2
 STORED d2,3
 LOADD d2,4; InlineFunc[void TraceB(bool)] Params Start
 COMPAREV d2,0
 GOTOCMP 25,0.0004
 LOADD d2,3
 COMPAREV d2,0
 GOTOCMP 25,0.0004
 LOADD d2,2
 COMPAREV d2,0
 GOTOCMP 20,0.0003
 LOADD d2,1
 COMPAREV d2,0
 GOTOCMP 20,0.0003
 GOTO 25
 LOADD d2,0
 COMPAREV d2,0
 GOTOCMP 25,0.0004
 SETV d3,1
 GOTO 26
 SETV d3,0
 TRACE2R d2; InlineFunc[void TraceB(bool)] Params End AND InlineFunc[void TraceB(bool)] Body
 POPARGS d5,0.0006
 QUIT; void run() Body End
```
`30 opcodes` -> `28 opcodes` in size, but it does a better job of skipping further ahead, so better optimization of num opcodes run.

=== @EmilyV99 (discord: Emily) 12/27/2023 03:41

and, there's more to opt here; a common pattern this creates is:```
(line N): GOTOCMP N+2,somecmp
GOTO somewhere
(line N+2):```
which should be optimizable to:```cpp
(line N): GOTOCMP somewhere,INVERT_CMP(somecmp)
(line N+2):
```

=== @EmilyV99 (discord: Emily) 12/27/2023 04:29

aand ok
final output:```cpp
 PUSHARGSV 0,0.0006; void run() Body Start
 SETR d4,SP
 SETV d2,1
 STORED d2,4
 SETV d2,2
 STORED d2,3
 LOADD d2,4; InlineFunc[void TraceB(bool)] Params Start
 COMPAREV d2,0
 GOTOCMP 24,0.0004
 LOADD d2,3
 COMPAREV d2,0
 GOTOCMP 24,0.0004
 LOADD d2,2
 COMPAREV d2,0
 GOTOCMP 19,0.0003
 LOADD d2,1
 COMPAREV d2,0
 GOTOCMP 24,0.0004
 LOADD d2,0
 COMPAREV d2,0
 GOTOCMP 24,0.0004
 SETV d3,1
 GOTO 25
 SETV d3,0
 TRACE2R d2; InlineFunc[void TraceB(bool)] Params End AND InlineFunc[void TraceB(bool)] Body
 POPARGS d5,0.0006
 QUIT; void run() Body End
```
`30 opcodes -> 28 opcodes -> 27 opcodes`
because we lose the re-using cmp values trick, we deal with this bit:
![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189424987900235786/image.png?ex=65e7f157&is=65d57c57&hm=4bcadff36c25e655d52f705b9a0d833122ee1b7e9ca4bc851f5b4399106a685f&)
giving the true or false value (that SETV will be `0.0001` depending on the compiler flag)

=== @EmilyV99 (discord: Emily) 12/27/2023 04:35

running update on the zasm tests, noticed a couple things:

![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189426408066404362/image.png?ex=65e7f2aa&is=65d57daa&hm=35dba97666c11b515ea0e15fcaa6866f74507d4ada92a1e896c42f494f4098b8&)
^ Occasionally, this will result in longer ZASM (Also that was setting `d3` instead of `d2`, whoops, fixed)

![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189426548063862875/image.png?ex=65e7f2cb&is=65d57dcb&hm=880e20578d73470a1f036559c58f69c067375e154cc0c5de5c6ab0d96620cad4&)
^...but occasionally, quite shorter

=== @EmilyV99 (discord: Emily) 12/27/2023 05:24

`cmp-opt` branch pushed
tests'll run
looks all good at face value to me

=== @EmilyV99 (discord: Emily) 12/27/2023 05:35

...wait nope, noticed a logical flaw

=== @EmilyV99 (discord: Emily) 12/27/2023 05:46

*that* should be right?
done for the night, so, tests can run lol

=== @EmilyV99 (discord: Emily) 12/27/2023 20:50

so, all those tests passed
also, I wanted to do a thing

![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189671724925599775/image.png?ex=65e8d722&is=65d66222&hm=4560a9e3ea21674dfa75e95d362cebe1bffe477479a09f633e91187bd94c210f&)
tada, it now actually uses the comparison symbols in the ZASM string output
(it prefixes them with `I` to indicate the `SET_CMPI` flag being enabled)

=== @EmilyV99 (discord: Emily) 12/27/2023 21:03

...this did require some changes to stuff that uses `script_command`
since it's now a type `2` (0 == reg, 1 == lit, 2 == cmp)

=== @connorjclark (discord: connorclark) 12/27/2023 21:11

i did the same thing locally lol

=== @EmilyV99 (discord: Emily) 12/27/2023 21:13

I noticed you had it in your debug output lol
also I just realized I fucked up
because uh, I optimized for sure... but didn't account for short-circuit being *off*.
which is a necessary compiler setting because short-circuit did not exist for old scripts

=== @EmilyV99 (discord: Emily) 12/27/2023 21:31

..*hmm*
so, I have some ideas for stuff, but like
The way to obviously clean this up a little, would end up *adding* jumps
which I feel like is bad, right?
but, the reason it would add jumps, is because jumps are one of the only ways to check compare results...

=== @EmilyV99 (discord: Emily) 12/27/2023 21:33

could I like, theoretically, just add a var to `ffscript` for each opcode, for a compare result condition?
I know the jit side has to handle compare result stuff specially... so not sure if that's a good idea or not
because then like, I can, for `&&` with NO short-circuit

=== @EmilyV99 (discord: Emily) 12/27/2023 21:36

The old way:```
[visit left]
PUSHR d2
[visit right]
POP d3
CASTBOOLF d2
CASTBOOLF d3
ADDR d2,d3
COMPAREV d2,0.0002
SETCMP d2,>=```

=== @EmilyV99 (discord: Emily) 12/27/2023 21:40

What I could do:```
PUSHV 1 ;or 0.0001, depending on SET_CMPI
[visit left]
COMPAREV d2,0
STACKWRITEATVV 0,0 $!=
[visit right]
COMPAREV d2,0
STACKWRITEATVV 0,0 $!=
POP d2```
assuming `$!=` there is the notation for `this opcode is conditional on CMP_NE`. Can go with whatever there.

=== @EmilyV99 (discord: Emily) 12/27/2023 21:42

(keep in mind that the `COMPAREV` can be further optimized if the `[visit left]`/`[visit right]` end in a `SETCMP`, so it would be even better in those cases - trimming both the COMPAREV and the SETCMP, and just changing the CMP_NE to whatever is equivalent then)

=== @connorjclark (discord: connorclark) 12/27/2023 21:45

(replying to @EmilyV99 (discord: Emily) "but, the reason it would addâ€¦"): Is this the same line of thought? Having trouble connecting this idea to the rest of your post

=== @EmilyV99 (discord: Emily) 12/27/2023 21:45

ah, yeah, let me uh

=== @EmilyV99 (discord: Emily) 12/27/2023 21:46

What I could do, but restricted to not having this new feature:```
PUSHV 1 ;or 0.0001, depending on SET_CMPI
[visit left]
COMPAREV d2,0
GOTOCMP lbla,!=
STACKWRITEATVV 0,0
lbla: nop
[visit right]
COMPAREV d2,0
GOTOCMP lblb,!=
STACKWRITEATVV 0,0 $!=
lblb: POP d2```
noting how I have to jump over the `STACKWRITEATVV` with a `GOTOCMP`, but by instead being able to just `$!=` to make the op itself conditional, I can remove the jumps

=== @EmilyV99 (discord: Emily) 12/27/2023 21:48

so basically you'd have `command, arg1, arg2, cmp_cond`
which `cmp_cond` would most often be `0`, indicating not to be conditional
(where `(cmp_cond & CMP_FLAGS)==CMP_FLAGS`, it can also be treated as non-conditional, as that's the 'Always True' condition)

=== @connorjclark (discord: connorclark) 12/27/2023 21:49

Can't we do the same with this new op code without adding all ops to have this conditional ability
Is stackwrite a new op?

=== @EmilyV99 (discord: Emily) 12/27/2023 21:50

(replying to @connorjclark (discord: connorclark) "Can't we do the same with thiâ€¦"): could, but like, I need to add a third arg for that then regardless

=== @connorjclark (discord: connorclark) 12/27/2023 21:50

STACKWRITEVV_IF, just a one off
Oh
Do you only need NE tho

=== @EmilyV99 (discord: Emily) 12/27/2023 21:50

unless I wanted to add `STACKWRITEVV_TRUE`,`STACKWRITEVV_FALSE`,etc
no
because if the `[visit left]` ends in a `SETCMP`
I need the `INVERT_CMP` of whatever that was using

=== @connorjclark (discord: connorclark) 12/27/2023 21:51

Yeah I'd say just do two new ops then

=== @EmilyV99 (discord: Emily) 12/27/2023 21:51

wouldn't be 2
just to make STACKWRITEVV conditional, I'd need... 6?
and then if I have another similar optimization anywhere else in the future that would need a different opcode, that'd be another 6
so, adding this as a new arg for all opcodes seems like the sanest solution
now, what I can do, is say it's only valid to use it on certain opcodes
so we can say for now it's only valid to use this on `STACKWRITEVV`
and then add more opcodes in the future if more use cases come up

=== @connorjclark (discord: connorclark) 12/27/2023 21:53

How about calling it arg3?
And just not making it specific to conditional, which implies all commands would support it

=== @EmilyV99 (discord: Emily) 12/27/2023 21:53

hmm
I suppose
though I don't want to just use STACKWRITEVV then
or, I'd want to do something on reading old quests, to update?
because like, if I don't treat it specially, technically a value of `0` would be `never` as far as `CMP` goes
so I'd want to set it to `CMP_FLAGS`
or, just add `STACKWRITEVV_IF` then, that takes a third arg for it
which, at that point, seems saner for sure
ok, arg3 it is

=== @EmilyV99 (discord: Emily) 12/27/2023 21:57

and for the interpreter, any conditional opcodes like this can just break if they fail and then fallthrough to the normal opcode

=== @connorjclark (discord: connorclark) 12/27/2023 21:57

Yup

Three args may be useful later for other new ops anyhow

And a new op is better than changing semantics of all ops

=== @EmilyV99 (discord: Emily) 12/27/2023 21:58

If it wouldn't have been too difficult on the jit side, having just the ability for ops to be conditional seems worthwhile in general imo
but, I suspect it wouldn't be easy lol

=== @connorjclark (discord: connorclark) 12/27/2023 21:58

It would be cumbersome on JIT and for other CFG/opt stuff I'm working on

=== @EmilyV99 (discord: Emily) 12/27/2023 21:59

aye. Third arg suffices, then.

=== @connorjclark (discord: connorclark) 12/27/2023 21:59

And just drawing a page from like...real instruction sets, no one does it like that
Which makes me think there be dragons

=== @EmilyV99 (discord: Emily) 12/27/2023 21:59

lol

=== @connorjclark (discord: connorclark) 12/27/2023 22:09

As far as jumps go- as long as they maintain the property that the resulting ZASM produces a reducible control flow graph..

See https://medium.com/leaningtech/solving-the-structured-control-flow-problem-once-and-for-all-5123117b1ee2 , basically loops have only a single entry ...


Then jumps are totally fine. Zscript has no go-to so this makes all programs (unless there is so compiler opt I don't know about...) be reducible, which makes certains things far simpler for the CFG analysis / web assembly stuff...
It would still be possible without that property but if it can be avoided that'd be great
I don't think anything you could do wrt to optimizing these short circuiting will be a problem regarding that, but just speaking generally about jumps

=== @connorjclark (discord: connorclark) 12/27/2023 22:11

In other words, if you added goto to zscript I would cry ðŸ˜¢
(aka spend like two weeks learning advanced compiler stuff, gross)

=== @EmilyV99 (discord: Emily) 12/27/2023 22:19

oof
yeah no plans for goto
the closest thing we do have though, is `break n;`
so like
```cpp
for(...)
{
    for(...)
    {
        if(failcond)
            break 2; //exits BOTH for loops
    }
}```

=== @connorjclark (discord: connorclark) 12/27/2023 22:21

That's fine

=== @EmilyV99 (discord: Emily) 12/27/2023 22:22

then yeah, no plans for anything more advanced lol

=== @connorjclark (discord: connorclark) 12/27/2023 22:22

btw there's no secret sauce for removing jmps for short circuiting. it's just how its gotta be done https://godbolt.org/z/cb9fo3h67
I have to believe with -O3 this is truly the best way to do it
but change 512 to 2 - something neat is happening there

=== @EmilyV99 (discord: Emily) 12/27/2023 22:24

interesting

=== @EmilyV99 (discord: Emily) 12/27/2023 22:42

...so uh, how do you feel about ```cpp
int32_t arg1;
int32_t arg2;```->```cpp
int32_t args[3];```
makes more sense to just make these things not care about specific size, yeah?

=== @connorjclark (discord: connorclark) 12/27/2023 22:59

ehh too much code change
Don't like

=== @EmilyV99 (discord: Emily) 12/27/2023 23:00

ahk, that's fair

=== @EmilyV99 (discord: Emily) 12/27/2023 23:27

OK, so, you know the giant tables in `ffscript.cpp` and `ffasm.cpp` that are duplicates of each other?
finally fucking working on deduping that by moving it to a separate file
(had to modify the entire table anyway to add third arg, so, might as well clean this up while I'm here)

=== @connorjclark (discord: connorclark) 12/28/2023 00:07

is there a version field you could bump somewhere so I can feature detect stuff like "this zasm already has improved compare instructions"?

=== @connorjclark (discord: connorclark) 12/28/2023 00:09

if not then nvm, isnt necessary

=== @EmilyV99 (discord: Emily) 12/28/2023 00:23

not aside from the normal `V_FFSCRIPT`
which is stored in the metadata per-script

=== @EmilyV99 (discord: Emily) 12/28/2023 01:31

haha ok
SCRIPT:```cpp
void run()
{
    int a,b,c,d,e,f;
    TraceB((a && b && c) || (d && e && f));
}```
OLD:```cpp
 PUSHR REFFFC; void run() Body Start
 PUSHARGSV 0,0.0006
 SETR d4,SP
 LOADD d2,5; InlineFunc[void TraceB(bool)] Params Start
 PUSHR d2
 LOADD d2,4
 POP d3
 CASTBOOLF d2
 CASTBOOLF d3
 ADDR d2,d3
 COMPAREV d2,0.0002
 SETCMP d2,0.0013
 PUSHR d2
 LOADD d2,3
 POP d3
 CASTBOOLF d2
 CASTBOOLF d3
 ADDR d2,d3
 COMPAREV d2,0.0002
 SETCMP d2,0.0013
 PUSHR d2
 LOADD d2,2
 PUSHR d2
 LOADD d2,1
 POP d3
 CASTBOOLF d2
 CASTBOOLF d3
 ADDR d2,d3
 COMPAREV d2,0.0002
 SETCMP d2,0.0013
 PUSHR d2
 LOADD d2,0
 POP d3
 CASTBOOLF d2
 CASTBOOLF d3
 ADDR d2,d3
 COMPAREV d2,0.0002
 SETCMP d2,0.0013
 POP d3
 CASTBOOLF d2
 CASTBOOLF d3
 ADDR d2,d3
 COMPAREV d2,0.0001
 SETCMP d2,0.0013; InlineFunc[void TraceB(bool)] Params End
 TRACE2R d2; InlineFunc[void TraceB(bool)] Body
 POPARGS d5,0.0007
 QUIT; void run() Body End
```
NEW:```cpp
 PUSHR REFFFC; void run() Body Start
 PUSHARGSV 0,0.0006
 SETR d4,SP
 PUSHV 0; InlineFunc[void TraceB(bool)] Params Start
 PUSHV 1
 LOADD d2,5
 COMPAREV d2,0
 STACKWRITEATVV_IF 0,0,==
 LOADD d2,4
 COMPAREV d2,0
 STACKWRITEATVV_IF 0,0,==
 LOADD d2,3
 COMPAREV d2,0
 STACKWRITEATVV_IF 0,0,==
 POP d2
 COMPAREV d2,0
 STACKWRITEATVV_IF 1,0,!=
 PUSHV 1
 LOADD d2,2
 COMPAREV d2,0
 STACKWRITEATVV_IF 0,0,==
 LOADD d2,1
 COMPAREV d2,0
 STACKWRITEATVV_IF 0,0,==
 LOADD d2,0
 COMPAREV d2,0
 STACKWRITEATVV_IF 0,0,==
 POP d2
 COMPAREV d2,0
 STACKWRITEATVV_IF 1,0,!=; InlineFunc[void TraceB(bool)] Params End
 POP d2; InlineFunc[void TraceB(bool)] Body Start
 TRACE2R d2; InlineFunc[void TraceB(bool)] Body End
 POPARGS d5,0.0007
 QUIT; void run() Body End
```
47 opcodes -> 34 opcodes

=== @EmilyV99 (discord: Emily) 12/28/2023 01:34

does use some stack space, but so did the old method, not sure if it uses more, less, or comparable
presumably uses less
since long chains of the same op only use a single stackspot

=== @EmilyV99 (discord: Emily) 12/28/2023 01:36

so, basically, for `&&`:
- Push `true` to the stack
- Visit each operand.
  - If the operand is falsy, overwrite the `true` on the stack with a `false`.
- Pop the value back off the stack, it is the return.
and for `||`, similarly:
- Push `false` to the stack
- Visit each operand.
  - If the operand is truthy, overwrite the `false` on the stack with a `true`.
- Pop the value back off the stack, it is the return.

=== @connorjclark (discord: connorclark) 12/28/2023 01:37

this is w/  "short circuiting" disabled option right?

=== @EmilyV99 (discord: Emily) 12/28/2023 01:37

aye, this is with short-circuit disabled
so it, by definition, must visit all the operands

=== @connorjclark (discord: connorclark) 12/28/2023 01:37

ok just making sure

=== @EmilyV99 (discord: Emily) 12/28/2023 01:37

(short-circuit enabled is as I showcased previously)
I just, completely forgot short-circuit being off was *an option*, which needed to be handled as well lol

=== @connorjclark (discord: connorclark) 12/28/2023 01:38

is that a global option or defined per script or what?
qr?

=== @EmilyV99 (discord: Emily) 12/28/2023 01:38

it's a compiler option
so, togglable per-scope

=== @connorjclark (discord: connorclark) 12/28/2023 01:38

so if you need a script that uses that, you must use it everywhere
..oh

=== @EmilyV99 (discord: Emily) 12/28/2023 01:38

`#option` directive
Not any scope, but any function-or-higher scope
so per-function, per-script, per-class, per-namespace, per-file

=== @connorjclark (discord: connorclark) 12/28/2023 01:39

may not be worth it to spend _too_ much time making a "deprecated" thing better

I know we can't remove it but still

=== @EmilyV99 (discord: Emily) 12/28/2023 01:39

well I had to do *something* because I had broken it lol

=== @connorjclark (discord: connorclark) 12/28/2023 01:40

ah, understood

=== @EmilyV99 (discord: Emily) 12/28/2023 01:40

and it took me not that much time, and we get a third arg for all opcodes available too from the same work

=== @connorjclark (discord: connorclark) 12/28/2023 01:40

what does VV mean

=== @EmilyV99 (discord: Emily) 12/28/2023 01:40

A lot of the opcodes use `R`/`V` for `Register`/`Immediate`

=== @connorjclark (discord: connorclark) 12/28/2023 01:41

oh ok

=== @EmilyV99 (discord: Emily) 12/28/2023 01:41

this one is indicating the R/V status of both it's first and second argument
so `STACKWRITERV` writes a register value to a literal offset
while `STACKWRITEVV` writes a literal value to a literal offset

=== @connorjclark (discord: connorclark) 12/28/2023 01:41

that reminds me, there's this ABS op that takes a register...
could we rename it to ABSR? the name in the source doesnt match the string name lol
and it mildly bothered me

=== @EmilyV99 (discord: Emily) 12/28/2023 01:42

technically renaming things breaks importing old zasm
....though, my `mergeslots` branch propsed doing so anyway
but uh, there's probably a lot of those
oh, also, btw
the whole `script_command ZASMcommands` and `script_variable ZASMVars` are gone from `ffscript.cpp`
replaced to reference the `command_list` and `variable_list` from `ffasm.cpp` instead
which, were moved to a new file `zasm_table.cpp` just for these two tables- since it needs to be shared between editor and player, with `ffscript.cpp` being player and `ffasm.cpp` being editor... so needed a file to put in both targets.
been meaning to do that forEVER

=== @EmilyV99 (discord: Emily) 12/28/2023 02:02

ahk, and my actual manual tests work
time to push all this...

=== @EmilyV99 (discord: Emily) 12/28/2023 02:12

...except, hmm
`STACKWRITEVV` isn't jit-compiled
and compare result using things need to be...
fek
time to do this

=== @connorjclark (discord: connorclark) 12/28/2023 02:13

look at stored
is probably similar to what you need to write
but conditionally
stored for how to write to stack given an offset

=== @connorjclark (discord: connorclark) 12/28/2023 02:15

via `cmov`

=== @EmilyV99 (discord: Emily) 12/28/2023 02:16

so, there's this

![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189753612608479373/image.png?ex=65e92365&is=65d6ae65&hm=9a0b76da490e729fd5fa3e68bb302c012c47926bf1330fd8fd36fae33dc7832e&)
but, I don't need to add a register to the offset- `arg2` itself is the whole offset

=== @connorjclark (discord: connorclark) 12/28/2023 02:17

`cc.cmov__(x86::ptr_32(state.ptrStack, arg2, 2), arg1);` i guess

=== @EmilyV99 (discord: Emily) 12/28/2023 02:17

(also, it's not off by *10000, so the div_10000 probably isn't needed either?)
ah, that easy?

![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189754033678852146/image.png?ex=65e923ca&is=65d6aeca&hm=8e7e024fb83eb970d5dcb47e6ee1cb5400eb96c32a34513b7458735a90960798&)

=== @connorjclark (discord: connorclark) 12/28/2023 02:18

i think its `cmove`
is there a non _IF variant too?

=== @EmilyV99 (discord: Emily) 12/28/2023 02:18

that's the non-conidtional one

=== @connorjclark (discord: connorclark) 12/28/2023 02:18

gotcha

=== @EmilyV99 (discord: Emily) 12/28/2023 02:18

figured I might as well jit that while I'm at it
so, how do I specify the conditional?

=== @connorjclark (discord: connorclark) 12/28/2023 02:18

in `compile_compare`
and also add to `command_uses_comparison_result`

=== @EmilyV99 (discord: Emily) 12/28/2023 02:19

yep, I have all that done already

=== @connorjclark (discord: connorclark) 12/28/2023 02:19

oh, well just like w/ SETCMP I think

=== @EmilyV99 (discord: Emily) 12/28/2023 02:19

(replying to @EmilyV99 (discord: Emily) ""): just need to convert this^ to be conditional, with `arg3` being the `CMP_` value
oh, duh

=== @connorjclark (discord: connorclark) 12/28/2023 02:19

you look at the cmp flags and pick the right `cmov__`

=== @EmilyV99 (discord: Emily) 12/28/2023 02:19

I'm getting brain-tired lol

=== @connorjclark (discord: connorclark) 12/28/2023 02:20

i've been staring at ZASM for days, I am brain dead.

=== @EmilyV99 (discord: Emily) 12/28/2023 02:20

what if anything do I need to do for `jit_wasm`?

=== @EmilyV99 (discord: Emily) 12/28/2023 02:23


![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189755383313612820/image.png?ex=65e9250b&is=65d6b00b&hm=c1a4e424aa3ce006d7e0bc2eb39b686b7c326a92e2923f3a74e44a81942794a1&)
ahk that should be right then

=== @connorjclark (discord: connorclark) 12/28/2023 02:25

maybe you can help me with this:

I let my compare optimization run just one time, and this is the change it made. however the replay fails, so it's doing something wrong. But it seems equivalent to me...

```
201: LOADD           D2              0            [Block 20 -> 21, 22]
202: COMPAREV        D2              40000        
203: SETCMP          D2              <            
204: COMPAREV        D2              0            
205: GOTOTRUE        209                          
206: LOADD           D2              20000        [Block 21 -> 22]
207: COMPAREV        D2              10000        
208: SETCMP          D2              >=           
209: COMPAREV        D2              0            [Block 22 -> 23, 29]
210: SETCMP          D2              !=           
211: COMPAREV        D2              0            
212: GOTOTRUE        260                          

after opt:

201: LOADD           D2              0            [Block 20 -> 21, 28]
202: COMPAREV        D2              40000        
203: GOTOCMP         260             <            
204: NOP                                          [Block 21 -> 22, 28]
205: NOP                                          
206: LOADD           D2              20000        
207: COMPAREV        D2              10000        
208: GOTOCMP         260             <            
209: NOP                                          [Block 22 -> 23, 24]
210: NOP                                          
211: NOP                                          
212: NOP                                          
```

pc 260 is some block of code that does not reuse D(2) or the comparison result, so it is not relevant

Does this look equivalent to you?

=== @connorjclark (discord: connorclark) 12/28/2023 02:26

if that first branch on 205 is hit, then the execution must end up in 260, so I rewrite it so. The comp op does not change.

=== @EmilyV99 (discord: Emily) 12/28/2023 02:26

`SETCMP d2,<` `COMPAREV d2,0` `GOTOTRUE` -> `GOTOCMP d2,>=`

=== @connorjclark (discord: connorclark) 12/28/2023 02:26

the second branch on 208 gets turned into equivalent code afaict

=== @EmilyV99 (discord: Emily) 12/28/2023 02:26

you have -> `GOTOCMP d2,<`, which is inverted
203 after opt

=== @connorjclark (discord: connorclark) 12/28/2023 02:28

follow that branch - it will go to 209, negate a few times, then jump to 260
THAT is what i am shortening

=== @connorjclark (discord: connorclark) 12/28/2023 02:29

if 205 jumps then `D2 >= 40000`
then it gets negated enough to become "jump to 260 if `D2 < 40000`"
so the opt passes detects that and does it directly

=== @EmilyV99 (discord: Emily) 12/28/2023 02:29

I think you're still off by one negation
let me try to trace it

=== @EmilyV99 (discord: Emily) 12/28/2023 02:35


![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189758562025603193/image.png?ex=65e92801&is=65d6b301&hm=bd81770dca22e4e65e69a90fcdcbe1221d876381f46515eb340cef8a81aeb7e0&)

=== @connorjclark (discord: connorclark) 12/28/2023 02:35

i think i see it

=== @EmilyV99 (discord: Emily) 12/28/2023 02:35

in your optimized version, it goes to `260` if `x < 4`
in the original, it goes to `260` if `x >= 4`

=== @connorjclark (discord: connorclark) 12/28/2023 02:36

`COMPAREV D2 0`  done TWICE is not a double negate

=== @EmilyV99 (discord: Emily) 12/28/2023 02:36

nope
because the previous compare wasn't SET to anything
it's not a double negate, it's a repeat of the previous operation
(effectively, a stupid NOP)

=== @connorjclark (discord: connorclark) 12/28/2023 02:37

amazing I hadn't run into this until now
thanks

=== @EmilyV99 (discord: Emily) 12/28/2023 02:37

(well, when jumped to- it's needed when flowed to from the previous opcode)
(which, that part you did handle right, turning the `>=` into `<`)

=== @EmilyV99 (discord: Emily) 12/28/2023 02:41

(replying to @EmilyV99 (discord: Emily) "what if anything do I need toâ€¦"): I uh, don't immediately see how to do the wasm part of this
you did SETCMP in a different way (just multiplying by 10k afterwards for CMP_SETI), so didn't use a `cmov` equivalent

=== @connorjclark (discord: connorclark) 12/28/2023 02:42

at the top of `jit_compile_script` you can just added this op to a "do not compile this script" check

=== @EmilyV99 (discord: Emily) 12/28/2023 02:43

...this is using postfix operator order
get register, emit constant, div to `x / const`

=== @connorjclark (discord: connorclark) 12/28/2023 02:43

wasm is a stack machine

=== @EmilyV99 (discord: Emily) 12/28/2023 02:43

makes sense

=== @connorjclark (discord: connorclark) 12/28/2023 02:43

I'm ok with you punting the wasm part

=== @EmilyV99 (discord: Emily) 12/28/2023 02:44

I should at least do the `STACKWRITEATVV` version without the comparing... shouldn't be that bad to figure out

=== @connorjclark (discord: connorclark) 12/28/2023 02:45

iirc it'd be copying how SETCMP does it, then replacing the internal bits with how STORED does it but like this


```
wasm.emitI32Const(arg2 * 4);
wasm.emitGlobalGet(g_idx_stack);
wasm.emitI32Add();
get_z_register(state, arg1);
wasm.emitI32Store();
```
i believe this is it
CI web replays run w/ jit on btw
the `g_idx_stack` global is the base stack pointer
oh you want rSFRAME huh

=== @connorjclark (discord: connorclark) 12/28/2023 02:48

```
get_z_register(state, rSFRAME);
wasm.emitI32Const(10000);
wasm.emitI32DivU();
wasm.emitI32Const(arg2 * 4);
wasm.emitI32Add();

wasm.emitGlobalGet(g_idx_stack);
wasm.emitI32Add();
get_z_register(state, arg1);
wasm.emitI32Store();
```

i think?

=== @EmilyV99 (discord: Emily) 12/28/2023 02:48

no, STACKWRITEVV doesn't use rSFRAME
but would it need rSP?
or, is stack pointer handled?

=== @connorjclark (discord: connorclark) 12/28/2023 02:48

what is 0 pointing to in that op

=== @EmilyV99 (discord: Emily) 12/28/2023 02:48

the most recently pushed item
sp+0

=== @connorjclark (discord: connorclark) 12/28/2023 02:49

gotcha, one sec

=== @EmilyV99 (discord: Emily) 12/28/2023 02:49


![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189762084238540800/image.png?ex=65e92b49&is=65d6b649&hm=c4522876383af7b9d856e6a8486003bba52a27e11da1f8e22efa3c4d39b5e857&)
this?

=== @connorjclark (discord: connorclark) 12/28/2023 02:50

`g_idx_sp` is the index into the stack
`g_idx_stack` is a pointer to the stack in memory
so you must add those two

=== @EmilyV99 (discord: Emily) 12/28/2023 02:50

ahk

![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189762303558680626/image.png?ex=65e92b7d&is=65d6b67d&hm=13e2a80570cb05ac35240f1e75d51bbe60ec2b3375052b82535bfb98f4524d33&)
so this?

=== @connorjclark (discord: connorclark) 12/28/2023 02:50

yes, but you can arg2*4
since it is constant

=== @EmilyV99 (discord: Emily) 12/28/2023 02:50

..oh, duh

=== @connorjclark (discord: connorclark) 12/28/2023 02:50

and drop the mul
ugh except

=== @EmilyV99 (discord: Emily) 12/28/2023 02:51


![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189762430805475378/image.png?ex=65e92b9c&is=65d6b69c&hm=57f761b9f9b1a7eabee00375c6d6e638a0077da1b61158e16cd871b810795767&)

=== @connorjclark (discord: connorclark) 12/28/2023 02:51

g_idx_sp is needed to be *4
(see PUSHV)

=== @EmilyV99 (discord: Emily) 12/28/2023 02:51

ah

![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189762543556776056/image.png?ex=65e92bb7&is=65d6b6b7&hm=80cce7ba7c804a25ecfc2e09c76cf82d92306fc38d6803adfc9e609b81dd16a5&)

=== @connorjclark (discord: connorclark) 12/28/2023 02:52

correct

=== @EmilyV99 (discord: Emily) 12/28/2023 02:53

and the compare stuff definitely looks over my head, so I'll leave that for you to handle
so how do I set scripts with `STACKWRITEATVV_IF` to not compile?

=== @connorjclark (discord: connorclark) 12/28/2023 02:54

top of jit_compile_script
near RUNGENFRZSCR

=== @EmilyV99 (discord: Emily) 12/28/2023 02:54

ah ok

=== @EmilyV99 (discord: Emily) 12/28/2023 03:08

err

![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189766881175941170/image.png?ex=65e92fc1&is=65d6bac1&hm=e4160e04d976d2ac49e1e77f5c8a39ff567034ada8b3d7df59b76256814c3cf3&)

=== @EmilyV99 (discord: Emily) 12/28/2023 03:11

what i need to do here
(`x86::ptr_32`, arguments don't match)

=== @EmilyV99 (discord: Emily) 12/28/2023 03:13

this?
![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189768135037964288/image.png?ex=65e930ec&is=65d6bbec&hm=40a8652163defa69ea70fdefea7342bad22feac4c38c35a47e4e6e8762b77318&)

=== @EmilyV99 (discord: Emily) 12/28/2023 03:15

fixed the `ptr_32`, but the movs don't like it now

=== @EmilyV99 (discord: Emily) 12/28/2023 03:17

ah, while `mov` can take an `int` for the second arg, the `cmov` variations cannot.
or, hmm

=== @EmilyV99 (discord: Emily) 12/28/2023 03:20

that's not it
something is wrong with the `cmov`s
...can they not take a `ptr_32`?

=== @EmilyV99 (discord: Emily) 12/28/2023 03:23

yep
that's fucking it

![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189770667546136596/image.png?ex=65e93348&is=65d6be48&hm=befeba200c3186b96f5798c290cd0321bce5753c78c410e6ca94f61e0de85baa&)
so I get to do *THIS* instead
Read the value from the stack
into a `x86::Gp`
and read `arg1` into an `x86::Gp`
then conditionally move between those Gps
and then move back to the stack
...that compiles now.

=== @connorjclark (discord: connorclark) 12/28/2023 03:27

always/never cases? its nop for never but always is missinghere

=== @EmilyV99 (discord: Emily) 12/28/2023 03:28

those are handled above now

![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189771835135512616/image.png?ex=65e9345e&is=65d6bf5e&hm=7dc1e27c780ff4ced58a71c641d1358e03727b6a59aeee1cdf34415c76bad679&)
so it doesn't have to bother with the stack read
since those don't require it

=== @connorjclark (discord: connorclark) 12/28/2023 03:29

`cc.mov(val, arg1)`

isnt arg2 the one with the value?

=== @EmilyV99 (discord: Emily) 12/28/2023 03:29

no
arg2 is the offset

=== @connorjclark (discord: connorclark) 12/28/2023 03:29

looks good then

=== @EmilyV99 (discord: Emily) 12/28/2023 03:30

`STACKWRITEATVV_IF val,offs,cmp`
pushed to `cmp-opt`

=== @connorjclark (discord: connorclark) 12/28/2023 03:30

btw that is not consistent with LOADD args
or stored

=== @EmilyV99 (discord: Emily) 12/28/2023 03:30

no, I think it's consistent with PEEK
because it's the inverse operation of PEEK

=== @connorjclark (discord: connorclark) 12/28/2023 03:31

doesnt matter to me, as long as you considered it

=== @EmilyV99 (discord: Emily) 12/28/2023 03:32

aye

=== @EmilyV99 (discord: Emily) 12/28/2023 03:34

..while the VV version actually wasn't used until now, the RV version I added with `loop()`
because `loop()` works by storing some values on the stack, and it uses `PEEKAT` to read them- but then I came across needing to *write* them

=== @EmilyV99 (discord: Emily) 12/28/2023 03:35


![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189773654792339456/image.png?ex=65e93610&is=65d6c110&hm=1ad134485754bba63bd5645917c3ec799e0529501cf14ec63a745616ae62d597&)
so, that's where it matches

=== @EmilyV99 (discord: Emily) 12/28/2023 08:28

(replying to @connorjclark (discord: connorclark) "could we rename it to ABSR? tâ€¦"): so, I see what you mean.
Renaming it to `ABSR`, would break importing old zasm scripts
...but renaming the constants to `ABS` to match, would be fine? so, should I do that?

=== @connorjclark (discord: connorclark) 12/28/2023 08:31

yeah it'd be a tad better

=== @EmilyV99 (discord: Emily) 12/28/2023 08:39

ooh, and it isn't the only one
just found 3 more
`STRINGUPPERLOWER`,`STRINGLOWERUPPER`,`STRINGCONVERTCASE`
constants lack the `STRING` part
or oh wait no
no
those are just duplication
fucking hell
so much duplication and unimplemented bullshit in this mess
zoriaaaaaaaaaaaaaaa

=== @EmilyV99 (discord: Emily) 12/28/2023 08:43


![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189851001491030016/image.png?ex=65e97e19&is=65d70919&hm=3bfb2b0d56da6aa475233dd3d18e110044ac3dae345a125a0f815c3ca503c42d&)

=== @connorjclark (discord: connorclark) 12/28/2023 08:46

how did he invent new ways to say reserved every other time

=== @EmilyV99 (discord: Emily) 12/28/2023 08:46

that could be different people using their own methods, that far back
maybe
plus, there's some opcodes here that are BROKEN

![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189852204690063420/image.png?ex=65e97f37&is=65d70a37&hm=764a15396d67a36caa4f18480204a95f525ecd37d4f49305d11267cd4e7885c4&)
possibly fixable, though to unknown compat effect
so just marking these as I find them

=== @EmilyV99 (discord: Emily) 12/28/2023 08:49

also I love some of these
like fucking
`UPPERTOLOWER`?
It takes 2 registers, yeah?
It both reads from and writes to the first register
and the second register is unused

![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189853077747028002/image.png?ex=65e98008&is=65d70b08&hm=523e0aa8e802373bcc83c5934ac190978e5e644f762f8347c02a7e540619e52a&)

=== @EmilyV99 (discord: Emily) 12/28/2023 08:59

this goes to like line 1200, and I'm at like 876

=== @EmilyV99 (discord: Emily) 12/28/2023 09:05

OH uh
`STRCMPR`/`STRICMPR` @connorjclark (discord: connorclark)
these opcodes do a string comparison of strings (read from their two registers)
...and then set the compare result flags based on them.
used IIRC for string-based switch-case

=== @EmilyV99 (discord: Emily) 12/28/2023 09:10


![image](https://cdn.discordapp.com/attachments/1189307068553891940/1189857998470905927/image.png?ex=65e9849d&is=65d70f9d&hm=d2ae59de951f3859858338f658a8653209e66462d29f54eaabd63d76448d6bbc&)
for now, have these all commented

=== @EmilyV99 (discord: Emily) 01/03/2024 07:22

(replying to @EmilyV99 (discord: Emily) ""): err, these were added as flags, never updated this thread tho

=== @EmilyV99 (discord: Emily) 01/03/2024 07:23

...unsure if I should close this (`STACKWRITEATVV_IF` still not handled for wasm... is that the only thing still hanging from this thread @connorjclark (discord: connorclark)?)

this is only open for you at this point, so if you have no need for this thread feel free to close

=== @connorjclark (discord: connorclark) 01/03/2024 07:24

That and gotta handle str compare stuff
I'll keep it open for those

=== @EmilyV99 (discord: Emily) 01/03/2024 07:25

ðŸ‘
